// ---------------------------------------------------------------
// History:
//
// Created by Evgueni Goudzovski (eg@hep.ph.bham.ac.uk) 2018-01-30
// ---------------------------------------------------------------

/// \class UpstreamPileupGenerator
/// \Brief
/// Generation of pileup activity in Cedar and GTK for MC events
/// \EndBrief
/// \Detailed
/// Pileup Cedar hits and candidates and pileup GTK hits are added to MC events
/// in the time window specified according to
/// the instantaneous beam intensity distribution specified.
/// The beam particle times and types for each event are generated by
/// PileupParticleGenerator, on the basis of instantaneous intensity
/// generated by BeamIntensityGenerator.
/// The library of GTK hits is built using MC simulations of beam tracks.
/// There is also an biased simulation option of generating exactly one
/// in-time pion (t=0), controllable via the GenerateIntimePion parameter.
/// An example of use of this option:
/// \code
/// ./MyExec -l file.list -p "UpstreamPileupGenerator::GenerateIntimePion=20"
/// \endcode
/// The valid values of the parameter above are 1-60000; each value leads to
/// a different (reproducible) sequence of GTK tracks generated.
/// Here 60000 is the current size of the hits library.
/// \author Evgueni Goudzovski (eg@hep.ph.bham.ac.uk)
/// \author Karim Massri (karim.massri@cern.ch)
/// \EndDetailed

#include "UpstreamPileupGenerator.hh"
#include "TGigaTrackerDigi.hh"
#include "TCedarDigi.hh"
#include "GeometricAcceptance.hh"
#include "NA62ConditionsService.hh"

using namespace std;
using namespace NA62Analysis;
using namespace NA62Constants;

#include "PileupParticleGenerator.hh"
#include "TRecoCedarEvent.hh"
#include "TRecoGigaTrackerEvent.hh"
#include "EventHeader.hh"

UpstreamPileupGenerator::UpstreamPileupGenerator(NA62Analysis::Core::BaseAnalysis *ba) :
  Analyzer(ba, "UpstreamPileupGenerator"),
  fTimeWindowWidth(-1), fCedarTimeResponse(nullptr), fKaonGenerated(false), fCedarEvent(nullptr), fGTKEvent(nullptr) {

  RequestBeamData();
  RequestTree("Cedar", new TRecoCedarEvent, "Reco");
  RequestTree("GigaTracker", new TRecoGigaTrackerEvent, "Reco");

  fCedarMeanNHitsPerKaon    = 18.0;
  fCedarMeanNHitsPerPion    =  0.6;
  fCedarMeanNHitsPerProton  =  0.0;
  fPixelTimeResolution      = 0.15; // [ns]

  // Cedar PMT time resolution (same as used in the digitizer)
  fCedarPMTTime_min  = -3.0;
  fCedarPMTTime_max  = +2.0;
  fCedarTimeResponse = new TF1
    ("CedarTimeResponse", "TMath::Gaus(x, 0, 0.161203) + \
                 0.1101571*TMath::Gaus(x, -0.1750211, 0.30081) + \
                 0.0290554*TMath::Exp(1.03047*(0.557182-2*x))*\
                 (1-TMath::Erf((0.282630-x)/0.0885416)) + \
                 0.0066920*TMath::Gaus(x, 1.47462, 0.167551)", fCedarPMTTime_min, fCedarPMTTime_max);

  AddParam("Enabled",            &fEnabled, true);
  AddParam("GTKHitInefficiency", &fGigaTrackerHitInefficiency, 0.04);
  AddParam("ForcedOnData",       &fForcedOnData, false);
  AddParam("GenerateInTimePion", &fGenerateInTimePion, 0); // 0=no

  fHitLibrary.clear();
  fRandom = new TRandom2();

  fCedarReco = new CedarReconstruction();
  fCedarReco->SetNCandidateClusteringIterations(2);
  fCedarReco->SetMinSectors(4);
  fCedarReco->SetMinPMTs(4);
  fCedarReco->SetTimeWindow(2.0);
  fCedarReco->SetNChannels(3072);
}

UpstreamPileupGenerator::~UpstreamPileupGenerator() {
  if (fCedarTimeResponse) delete fCedarTimeResponse;
  if (fCedarReco) delete fCedarReco;
}

void UpstreamPileupGenerator::InitHist() {
  double intstep = 1000.0/(3*45.0);
  BookHisto(new TH1F("TrueBeamIntensity", "TrueBeamIntensity",
		     340, -0.5*intstep, 339.5*intstep));
  BookHisto(new TH1F("MeasuredBeamIntensity", "MeasuredBeamIntensity",
		     340, -0.5*intstep, 339.5*intstep));
}

void UpstreamPileupGenerator::InitOutput() {
  RegisterOutput("Enabled",       &fEnabled);
  RegisterOutput("KaonGenerated", &fKaonGenerated);
}

void UpstreamPileupGenerator::StartOfRunUser() {
  if (!fEnabled) return;
  if (!GetWithMC() && !fForcedOnData) return;
  if (!GetIsTree()) return;
  ReadGtkHitLibrary();
}

void UpstreamPileupGenerator::StartOfBurstUser() {
  if (!GetIsTree()) return;
  if (!GetEventHeader()) return;
  fRandom->SetSeed(GetEventHeader()->GetBurstID()); // to ensure reproducibility
}

void UpstreamPileupGenerator::ReadGtkHitLibrary() {
  fHitLibrary.clear();

  TString LibName = "GTKPileupGeneratorLibrary.dat";
  if (NA62ConditionsService::GetInstance()->Open(LibName)==kSuccess) {
    TString Line;
    std::vector<Int_t> entry;
    while (Line.ReadLine(NA62ConditionsService::GetInstance()->Get(LibName))) {
      if (Line.BeginsWith("#")) continue;
      TObjArray *l = Line.Tokenize(" ");
      entry.clear();
      for (Int_t i=0; i<=l->GetLast(); i++) {
	Int_t N = ((TObjString*)(l->At(i)))->GetString().Atoi();
	entry.push_back(N);
      }
      delete l;
      fHitLibrary.push_back(entry);
    }
    NA62ConditionsService::GetInstance()->Close(LibName);
  }
  if (fHitLibrary.size()>=1000) {
    cout << user_normal() << "Found " << fHitLibrary.size() << " entries in hit library" << endl;
  }
  else {
    cout << user_normal() << "Error: " << fHitLibrary.size() << " entries in hit library are too few" << endl;
    exit(kGenericError);
  }
}

void UpstreamPileupGenerator::Process(Int_t) {
  if (!fEnabled) return;
  if (!GetWithMC() && !fForcedOnData) return;
  if (!GetIsTree()) return;
  if (!GetEventHeader()) return; // do not run on NA62MC output

  fKaonGenerated = false;
  fGTKEvent   = GetEvent<TRecoGigaTrackerEvent>();
  fCedarEvent = GetEvent<TRecoCedarEvent>();

  if (!fGenerateInTimePion) { // standard mode

    // Get the generated beam particles for this event
    UpstreamParticles* beamParticles =
      (UpstreamParticles*)GetOutput("PileupParticleGenerator.BeamParticles");
    UpstreamParticles::iterator particle = beamParticles->begin();

    // Loop over thegenerated particles
    for( ; particle != beamParticles->end(); ++particle){
      Double_t time    = particle->first;
      Int_t particleID = particle->second; // 0=kaon, 1=pion, 2=proton
      AddTrack(time, particleID, fRandom->Integer(fHitLibrary.size()));
    }
  }

  else {
    // Generate exactly one pion with time = 0:
    // the ID of the track taken from the library is determined
    // by the value of the fGenerateInTimePion parameter.
    Int_t TrackID = fRandom->Integer(fHitLibrary.size()) + fGenerateInTimePion;
    TrackID = TrackID % fHitLibrary.size();
    AddTrack(0.0, 1, TrackID);
  }

  // GigaTracker hit inefficiency simulation
  for (Int_t iHit=0; iHit<fGTKEvent->GetNHits(); iHit++) {
    if (fRandom->Uniform()<fGigaTrackerHitInefficiency) {
      fGTKEvent->RemoveHit(iHit);
      iHit--;
    }
  }

  // Determine intstantaneous beam intensity accounting for GTK inefficiency
  EvaluateInstantaneousIntensity(); // copy-paste from NA62Reconstruction

  // Remove all Cedar candidates and rerun Cedar reconstruction
  while (fCedarEvent->GetNCandidates()) fCedarEvent->RemoveCandidate(0);
  fCedarReco->ReconstructCandidates(fCedarEvent);
}

void UpstreamPileupGenerator::AddTrack(Double_t Time, Int_t particleID, Int_t trackID) {

  // Add pileup GTK hits
  TGigaTrackerDigi* GTKDigi = new TGigaTrackerDigi();
  for (UInt_t j=0; j<fHitLibrary[trackID].size(); j++) {
    TRecoGigaTrackerHit *hit = static_cast<TRecoGigaTrackerHit*>(fGTKEvent->AddHit(GTKDigi));
    hit->SetChannelID(fHitLibrary[trackID][j]);
    hit->DecodeChannelID();
    hit->SetTime(fRandom->Gaus(Time, fPixelTimeResolution));
  }
  delete GTKDigi;

  Double_t CedarMeanNHits = fCedarMeanNHitsPerProton;
  if (particleID==0){ // kaon
    CedarMeanNHits = fCedarMeanNHitsPerKaon;
    fKaonGenerated = true;
  }
  else if (particleID==1){ // pion
    CedarMeanNHits = fCedarMeanNHitsPerPion; // Pion
  }

  // Add pileup Cedar kaon/pion hits according to beam composition
  TCedarDigi* CedarDigi = new TCedarDigi();
  Int_t NHitsToBeAdded = fRandom->Poisson(CedarMeanNHits);
  Int_t NHitsInSector[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  for (Int_t iHit=0; iHit<NHitsToBeAdded; iHit++) {
    TRecoCedarHit *hit = static_cast<TRecoCedarHit*>(fCedarEvent->AddHit(CedarDigi));
    Int_t iSector   = (Int_t)fRandom->Integer(8);
    Int_t ChannelID = 100*(iSector+1)+55; // dummy channel ID, it doesn't matter
    Int_t ROChannelID = ChannelID; // dummy channel ID, it doesn't matter
    hit->SetChannelID(ChannelID);
    hit->SetROChannelID(ROChannelID);
    hit->DecodeChannelID();
    TRandom *r = gRandom;
    gRandom = fRandom;
    hit->SetTime(Time + fCedarTimeResponse->GetRandom(fCedarPMTTime_min, fCedarPMTTime_max));
    gRandom = r;
    NHitsInSector[iSector]++;
  }
  delete CedarDigi;
}

void UpstreamPileupGenerator::EndOfJobUser() {
  if (!fEnabled)    return;
  if (!GetWithMC() && !fForcedOnData) return;
  if (!GetIsTree()) return;
  SaveAllPlots();
}

//////////////////////////////////
// Print the whole GTK hit library

void UpstreamPileupGenerator::Print() {
  if(!TestLevel(Verbosity::kUserNormal))
    return;
  for (UInt_t i=0; i<fHitLibrary.size(); i++) {
    cout << "Event " << i << ": number of hits = " << fHitLibrary[i].size() << endl;
    for (UInt_t j=0; j<fHitLibrary[i].size(); j++) {
      cout << fHitLibrary[i][j] << " ";
    }
    cout << endl;
  }
}

void UpstreamPileupGenerator::EvaluateInstantaneousIntensity(){
  if(!GetEventHeader()){
    std::cout << user_normal() << "Error: No event header!" << std::endl;
    return;
  }

  Double_t ReferenceTime = GetEventHeader()->GetFineTime()*ClockPeriod/256;

  // Instantaneous intensity variables
  const Double_t CentralGap    =   5.00; //ns [-2.50,2.50]
  const Double_t LowerEdgeTime = -25.00; //ns
  const Double_t UpperEdgeTime = +25.00; //ns
  const Double_t T0Offset      =   0.0;  //ns (no offset for MC)

  // Evaluate instantaneous beam intensity using GigaTracker
  Double_t  Lambda[3] = {0.,0.,0.};
  Double_t eLambda[3] = {0.,0.,0.};
  for (Int_t iHit=0; iHit<fGTKEvent->GetNHits(); iHit++) {
    TRecoGigaTrackerHit *RecoHit = static_cast<TRecoGigaTrackerHit*>(fGTKEvent->GetHit(iHit));
    Double_t Time = RecoHit->GetTime();
    //Int_t ChID    = RecoHit->GetChannelID();
    Int_t StationID = RecoHit->GetStationNo();
    if(fabs(Time-ReferenceTime)<0.5*CentralGap)   continue; //in-time hit
    if(Time-ReferenceTime<LowerEdgeTime-T0Offset) continue; //hit too close to the lower edge
    if(Time-ReferenceTime>UpperEdgeTime-T0Offset) continue; //hit too close to the upper edge
    Lambda[StationID]++; // Best estimator of Poissonian parameter
  }
  Double_t  Average = 0.;
  Double_t eAverage = 0.;
  for (Int_t iStation=0; iStation<3; iStation++) {
    eLambda[iStation] = sqrt(Lambda[iStation]); //it must be before conversion
    // Conversion counts -> MHz
    Double_t SampleTimeInterval = UpperEdgeTime-LowerEdgeTime-CentralGap;
    Lambda[iStation] /= 0.001*SampleTimeInterval;
    eLambda[iStation] /= 0.001*SampleTimeInterval;
    Average  += Lambda[iStation];
    eAverage += pow(eLambda[iStation],2.);
  }
  Average/=3.;
  eAverage = sqrt(eAverage)/3.;

  GetBeamData()->Clear();
  GetBeamData()->AddInstantaneousIntensity(Average);
  GetBeamData()->AddInstantaneousIntensityError(eAverage);

  Double_t trueIntensity = *(Double_t*)GetOutput("BeamIntensityGenerator.BeamIntensity");
  FillHisto("TrueBeamIntensity", trueIntensity);
  FillHisto("MeasuredBeamIntensity", Average);
}

void UpstreamPileupGenerator::PostProcess(){
  if (!GetWithMC() && !fForcedOnData) return;
  if (!GetIsTree()) return;
  fCedarEvent->Clear();
  fGTKEvent->Clear();
}
