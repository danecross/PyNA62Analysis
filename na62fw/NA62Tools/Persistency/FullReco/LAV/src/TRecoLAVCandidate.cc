// --------------------------------------------------------------
// History:
//
// 2015-03-19 T. Spadaro (tommaso.spadaro@lnf.infn.it)
// - promoting c++ variables to root types wherever possible
// - adding method to retrieve cluster centroid error matrix
// - adding a cluster type flag (fClusterType) to identify MIP-like and shower-like cluster topologies
// - adding an algorithm type flag (fAlgorithmType) to identify used algorithm: adjacent-block-grouping and/or phi-vs-time-grouping (a.k.a tracking)
// 2015-01-22 First implementation of Clustering and revision by T. Spadaro and E. Leonardi
// Created by Antonino Sergi (Antonino.Sergi@cern.ch) 2009-10-04
//
// --------------------------------------------------------------
/// \class TRecoLAVCandidate
/// \Brief
/// Class for LAV Candidates, i.e., clusters of nearby blocks.
/// \EndBrief
/// 
/// \Detailed
/// Instances of this class are created by two different algorithms:\n
/// the one managed by the LAVClusterMaker class, which groups adjacent clusters, close in time wrt a seed block;\n
/// the one managed by the LAVTrackfinder class, which groups blocks close in time and azimuthal angle.\n
/// \n Cluster information include: the number of hits per each layer in the cluster; 
/// the centroid position obtained averaging azimuthal angles and z-positions with and without using the block energy (at present, in fact, the block charge) as weight;\n
/// the errors on the phi and z estimates; a clusterType flag to tag clusters as due to MIP's or to showers.
/// \EndDetailed
#include "TRecoLAVCandidate.hh"
#include "TMath.h"
#include "iostream"

ClassImp(TRecoLAVCandidate)

TRecoLAVCandidate::TRecoLAVCandidate() : TRecoVCandidate()
{
  fPosition.SetXYZ(0,0,0);
  fWeightedPosition.SetXYZ(0,0,0);
  for (Int_t i=0; i<5; i++) fNHitsPerLayer[i]=0;
  fAlgorithm = kNotPass; // =0 if cluster is generated by grouping adjacent blocks; =1 if clustering is generated by grouping blocks close in phi and time (so-called "tracking")
  fClusterType = kUnknown;
}

void TRecoLAVCandidate::Clear(Option_t* option){
  TRecoVCandidate::Clear(option);
  fPosition.SetXYZ(0,0,0);
  fWeightedPosition.SetXYZ(0,0,0);
  for (Int_t i=0; i<5; i++) fNHitsPerLayer[i]=0;
  fAlgorithm = kNotPass; // =0 if cluster is generated by grouping adjacent blocks; =1 if clustering is generated by grouping blocks close in phi and time (so-called "tracking")
  fClusterType = kUnknown;
}


Double_t TRecoLAVCandidate::GetCentroidErrorMatrix(TVector3 position, Double_t sigmaPhi, Double_t sigmaZ, Double_t /*SigmaR*/, Int_t i1, Int_t i2){
/// \MemberDescr
/// Retrieve the error matrix component (i1,i2), where i1,i2 = 0,1,2 correspond to x,y,z
/// At present, phi and Z estimates are considered independent
/// \param[In] position Centroid position (cm)
/// \param[In] sigmaPhi Error on the phi angle estimate (rad)
/// \param[In] sigmaZ Error on the z coordinate (cm)
/// \param[In] sigmaR Error on the transverse position (cm) - at the moment this is not used
/// \param[In] i1 Index of error matrix row (i1=0,1,2, for x,y,z)
/// \param[In] i2 Index of error matrix column (i2=0,1,2, for x,y,z)
/// \EndMemberDescr

  if (i1 < 0 || i1 > 2) {
    cerr << "TRecoLAVCandidate >> GetCentroidErrorMatrix: wrong first index in input: " << i1 << endl;
    return 0;
  }
  if (i2 < 0 || i2 > 2) {
    cerr << "TRecoLAVCandidate >> GetCentroidErrorMatrix: wrong second index in input: " << i2 << endl;
    return 0;
  }

  Double_t phi = position.Phi();
  Double_t rho = position.Perp();

  Double_t usedSigmaR = 10.7; // 37 cm / sqrt(12), assume a uniform distribution on R
  Double_t errorMatrix[3][3];
  Double_t cosPhi = TMath::Cos(phi);
  Double_t sinPhi = TMath::Sin(phi);

  errorMatrix[0][0] = cosPhi*cosPhi*usedSigmaR*usedSigmaR + sinPhi*sinPhi*rho*rho*sigmaPhi*sigmaPhi;
  errorMatrix[1][1] = sinPhi*sinPhi*usedSigmaR*usedSigmaR + cosPhi*cosPhi*rho*rho*sigmaPhi*sigmaPhi;
  errorMatrix[0][1] = cosPhi*sinPhi*(usedSigmaR*usedSigmaR - rho*rho*sigmaPhi*sigmaPhi);
  errorMatrix[0][2] = 0;
  errorMatrix[1][2] = 0;
  errorMatrix[2][2] = sigmaZ*sigmaZ;
  Int_t id1 = i1;
  Int_t id2 = i2;
  if (i2 < i1) {
    id1 = i2;
    id2 = i1;
  }
  return errorMatrix[id1][id2];
}
