#include <iostream>

#include "Riostream.h"

#include "HACDigitizer.hh"
#include "HACReconstruction.hh"
#include "THACHit.hh"
#include "TDCEvent.hh"
#include "TSpecialTriggerEvent.hh"
#include "TDCBRawDecoder.hh"
#include "NA62RecoManager.hh"
#include "NA62ConditionsService.hh"

#include "CLHEP/Units/SystemOfUnits.h"
using namespace CLHEP;

HACDigitizer::HACDigitizer(NA62VReconstruction* Reco) :
  NA62VDigitizer(Reco, "HAC"),
  HACEvent(nullptr)
{
  fDigiEvent = new TDCEvent(THACDigi::Class());
  //Attributes of HACDigitizer class can be found in HACReconstruction
  TString signalFileName = static_cast<HACReconstruction*>( fReco)->GetSignalParametersFileName();
  fThresholdValues = static_cast<HACReconstruction*>( fReco)->GetThresholdValues();
  ReadSignalParametersFile(signalFileName);
}

void HACDigitizer::ReadSignalParametersFile(TString signalFileName) {
  //Start reading signal parameters
  NA62ConditionsService::GetInstance()->Open(signalFileName);

  TString Line;
  while (Line.ReadLine(NA62ConditionsService::GetInstance()->Get(signalFileName))) {
    if (Line.BeginsWith("#"))
      continue;
    else if (Line.BeginsWith("MeanNphEnergy=")) { //number of photons generated by 1 MeV energy deposit
      TObjArray *l = Line.Tokenize(" ");
      fMeanNph = static_cast<TObjString*>(l->At(1))->GetString().Atof();
      delete l;
      continue;
    } else if (Line.BeginsWith("MeanNphEnergySigma=")) { //sigma of the above value
      TObjArray *l = Line.Tokenize(" ");
      fMeanNphSigma = static_cast<TObjString*>(l->At(1))->GetString().Atof();
      delete l;
      continue;
    } else if (Line.BeginsWith("WLSTrappingEfficiency=")) { //Photon trapping efficiency of the WLS fiber
      TObjArray *l = Line.Tokenize(" ");
      fWLStrappingEff = static_cast<TObjString*>(l->At(1))->GetString().Atof();
      delete l;
      continue;
    } else if (Line.BeginsWith("WLSAttenuationLength=")) { //Attenuation length after the relation: I(x) = I0 *Exp(-x/l)
      TObjArray *l = Line.Tokenize(" ");
      fWLSattenuationLength = static_cast<TObjString*>(l->At(1))->GetString().Atof();
      delete l;
      continue;
    } else if (Line.BeginsWith("WLSlightspeed=")) {
      TObjArray *l = Line.Tokenize(" ");
      fWLSlightSpeed = static_cast<TObjString*>(l->At(1))->GetString().Atof();
      delete l;
      continue;
    } else if (Line.BeginsWith("WLSlength=")) { //length of the fiber. Equal for all fibers
      TObjArray *l = Line.Tokenize(" ");
      fDistanceFromSiPM = static_cast<TObjString*>(l->At(1))->GetString().Atof();
      delete l;
      continue;
    } else if (Line.BeginsWith("SiPMpde=")) { //Photon detection efficiency of the SiPM
      TObjArray *l = Line.Tokenize(" ");
      fPDE = static_cast<TObjString*>(l->At(1))->GetString().Atof();
      delete l;
      continue;
    } else if (Line.BeginsWith("NPixelsTotal=")) { //Number of all pixels in one SiPM
      TObjArray *l = Line.Tokenize(" ");
      fNpixelsTotal = static_cast<TObjString*>(l->At(1))->GetString().Atof();
      delete l;
      continue;
    } else if (Line.BeginsWith("SiPMGain=")) {
      TObjArray *l = Line.Tokenize(" ");
      fSiPMgain = static_cast<TObjString*>(l->At(1))->GetString().Atof();
      delete l;
      continue;
    } else if (Line.BeginsWith("ChargePerPixelFired=")) { //Charge generated by on fired pixel
      TObjArray *l = Line.Tokenize(" ");
      fChargePerPixel = static_cast<TObjString*>(l->At(1))->GetString().Atof();
      delete l;
      continue;
    } else if (Line.BeginsWith("RiseTime=")) { //Signal rise time
      TObjArray *l = Line.Tokenize(" ");
      fRiseTime = static_cast<TObjString*>(l->At(1))->GetString().Atof();
      delete l;
      continue;
    } else if (Line.BeginsWith("RiseTimeSigma=")) {
      TObjArray *l = Line.Tokenize(" ");
      fRiseTimeSigma = static_cast<TObjString*>(l->At(1))->GetString().Atof();
      delete l;
      continue;
    } else if (Line.BeginsWith("AmplitudeChargeConstant=")) {
      TObjArray *l = Line.Tokenize(" ");
      fMaxAmplChargeConstant = static_cast<TObjString*>(l->At(1))->GetString().Atof();
      delete l;
      continue;
    } else if (Line.BeginsWith("AmplitudeChargeSlope=")) {
      TObjArray *l = Line.Tokenize(" ");
      fMaxAmplChargeSlope = static_cast<TObjString*>(l->At(1))->GetString().Atof();
      delete l;
      continue;
    } else if (Line.BeginsWith("ChannelResolution=")) {
      TObjArray *l = Line.Tokenize(" ");
      fChannelTimeResolution = static_cast<TObjString*>(l->At(1))->GetString().Atof();
      delete l;
      continue;
    } else if (Line.BeginsWith("ChargeToTOffset=")) {
      TObjArray *l = Line.Tokenize(" ");
      for (Int_t ithr = 0; ithr < 4; ithr++)
        fChargeToTOffset.push_back(static_cast<TObjString*>(l->At(ithr + 1))->GetString().Atof());
      delete l;
      continue;
    } else if (Line.BeginsWith("ChargeToTConstant=")) {
      TObjArray *l = Line.Tokenize(" ");
      for (Int_t ithr = 0; ithr < 4; ithr++)
        fChargeToTConstant.push_back(static_cast<TObjString*>(l->At(ithr + 1))->GetString().Atof());
      delete l;
      continue;
    } else if (Line.BeginsWith("ChargeToTSlope=")) {
      TObjArray *l = Line.Tokenize(" ");
      for (Int_t ithr = 0; ithr < 4; ithr++)
        fChargeToTSlope.push_back(static_cast<TObjString*>(l->At(ithr + 1))->GetString().Atof());

      delete l;
      continue;
    }
  }
  NA62ConditionsService::GetInstance()->Close(signalFileName);
}

HACDigitizer::~HACDigitizer() {
}

TDetectorVEvent * HACDigitizer::ProcessEvent(TDetectorVEvent * tEvent) {

  if (tEvent->GetHits()->GetClass()->InheritsFrom("TVDigi") ||
      tEvent->IsA() == TSpecialTriggerEvent::Class())
    return tEvent;

  HACEvent = static_cast<THACEvent*>( tEvent);
  Int_t NHits = HACEvent->GetNHits();

  //printf("NHits = %d \n", NHits);
  fDigiEvent->Clear();
  (*(TVEvent*) fDigiEvent) = (*(TVEvent*) HACEvent);

  if (!NHits) return fDigiEvent;

  //In order to pass from HACHit to digis the procedure is this:
  //Sum energy release in each SiPM, which gives the whole signal.
  //The energy is converted in photons in the scintillator plates.
  //The photons are trapped by a WLS fiber and transported to the SiPM.
  //Here they fire a number of pixels which give the total charge of the signal.
  //The amplitude and ToT of the signal can be computed using the charge.

  //Loop over MC hits and filling of relevant vectors
  std::vector<Bool_t> isAdded(NHits, kFALSE); //container to keep track of hits already clustered
  for (Int_t iHit = 0; iHit < NHits; iHit++) {
    if (isAdded[iHit] == kTRUE)
      continue;
    isAdded[iHit] = kTRUE;

    THACHit *hit1 = static_cast<THACHit*>( HACEvent->GetHit(iHit));
    Int_t ich = hit1->GetChannelID();
    Double_t channelEnergy = hit1->GetEnergy();
    Double_t channelTime = hit1->GetTime();

    for (Int_t jHit = iHit + 1; jHit < NHits; jHit++) {
      if (isAdded[jHit] == kTRUE)
        continue;

      THACHit *hit2 = static_cast<THACHit*>( HACEvent->GetHit(jHit));
      if (ich == hit2->GetChannelID() && //clustering condition
          fabs(channelTime - hit2->GetTime()) < fChannelTimeResolution) {
        channelEnergy += hit2->GetEnergy();
        isAdded[jHit] = kTRUE;
        channelTime = hit1->GetTime() < hit2->GetTime() ? hit1->GetTime() : hit2->GetTime();
      }
    }
    Double_t charge = EnergyToCharge(channelEnergy);
    CreateDigiStructure(ich, iHit, charge, channelTime);
  }
  return fDigiEvent;
}

//This method creates a digi for each threshold passed by the signal in a given
//channel.

void HACDigitizer::CreateDigiStructure(const Int_t& ich, const Int_t& iHit, const Double_t& charge, const Double_t& channelTime) {
  Double_t riseSlope = 0;
  Int_t nThresholds = GetNThresholds(ich, charge, riseSlope);
  if (nThresholds < 1) //in the case fNThresholds = 0, the signal would not be detected
    return; //simulate threshold behavior
  THACHit *hit = static_cast<THACHit*>( HACEvent->GetHit(iHit));
  Double_t slewingCorrection = 0.;
  for (Int_t ithr = 0; ithr < nThresholds; ithr++) {
    Int_t chID = ich + 100 * ithr; //Position ID
    Int_t iROch = //Readout channel
      static_cast<TDCBRawDecoder*>(static_cast<HACReconstruction*>(fReco)->GetRawDecoder()->GetDecoder())->GetChannelRO(chID);
    //if channel is not instrumented continue
    if (iROch < 0)
      continue;

    //Create Digi for this threshold
    Double_t tot = ChargeToTconversion(charge, ithr);
    if (tot < 5.)
      break;

    if (ithr == 0) //ensures slewing correction is a global offset for the physical channel
      slewingCorrection = static_cast<HACReconstruction*>( fReco)->SlewCorrection(tot, chID);

    Double_t FineTime = NA62RecoManager::GetInstance()->GetEventHeader()->GetFineTime()*ClockPeriod/256.;

    Double_t correctedTime = channelTime + FineTime
      - static_cast<HACReconstruction*>(fReco)->GetStationMCToF(hit->GetStationID()) +
      +fReco->GetT0Correction(hit->GetChannelID(), hit->GetStationID()) + fChannels[iROch]->GetT0()+
      slewingCorrection + 0.2 * ithr;
    Double_t digitizedTime = (Int_t) (correctedTime / ns / TdcCalib) * TdcCalib; //this is the leading time of this digi.
    //For the trailing time, the ToT of this threshold is computed

    THACDigi *newDigi = static_cast<THACDigi*>( fDigiEvent->AddDigi(hit));
    newDigi->SetChannelID(chID);
    newDigi->DecodeChannelID();
    newDigi->SetLeadingEdge(digitizedTime);
    newDigi->SetTrailingEdge(digitizedTime + (Int_t) (tot / ns / TdcCalib) * TdcCalib);
    newDigi->SetDetectedEdge(3);
  }
}

//This method retrieves the number of thresholds passed by the signal of a given
//energy by converting this energy to the maximum amplitude and has as an output
//variable the slope of the rising signal.

Int_t HACDigitizer::GetNThresholds(const Int_t &ich, const Double_t& charge, Double_t& riseSlope) {
  Int_t nThreholds = 0;
  //Convert the charge to maximum amplitude to see how many thresholds
  // did it pass. There must be one digi for each threshold.
  Double_t maxAmpl = fabs(fMaxAmplChargeConstant + fMaxAmplChargeSlope * charge); //in mV
  maxAmpl = maxAmpl / 1000.; //in V
  if (maxAmpl >= fThresholdValues[4 * ich] / 1000.)
    nThreholds = 1;
  if (maxAmpl >= fThresholdValues[4 * ich + 1] / 1000.)
    nThreholds = 2;
  if (maxAmpl >= fThresholdValues[4 * ich + 2] / 1000.)
    nThreholds = 3;
  if (maxAmpl >= fThresholdValues[4 * ich + 3] / 1000.)
    nThreholds = 4;

  riseSlope = 0.8 * maxAmpl / fRiseTime;
  return nThreholds;
}


//This method converts the energy deposited in one hit in signal charge.
//The procedure is the following:
// Compute the number of photons resulted from the energy deposit. After propagating
//those photons through the fiber, only a fraction from the initial number remain.
//this latter number is used to compute the number of pixels fired taking into account 
//the photon detection efficiency of the SiPM and the total number of pixels in one SiPM.
//Each fired pixel contributes with the same amount to the total charge of the signal.

Double_t HACDigitizer::EnergyToCharge(const Double_t& hitEnergy) {
  Double_t numberOfPhotons = hitEnergy * pow(10, 5); //number of photons generated by energy dep.
  //numberOfPhotons = fRandom->Gaus(numberOfPhotons, fMeanNphSigma); // randomization due to photon creation mechanism
  //Number of Photons after WLS fiber: trapping and attenuation factors
  numberOfPhotons = fWLStrappingEff * numberOfPhotons;
  numberOfPhotons = numberOfPhotons * TMath::Exp(-fDistanceFromSiPM / fWLSattenuationLength);
  //Number of pixels fired by the remaining photons:
  Double_t nPixelsFired = fNpixelsTotal * (1. - TMath::Exp(-fPDE * numberOfPhotons / fNpixelsTotal));
  return nPixelsFired * fChargePerPixel;
}

//The relation between charge and ToT is given in HACDigitizer.hh and in 
//HAC-SignalParameters.dat. This method computes the inverse of above function
//and returns the value of ToT in each threshold passed at a given total charge.

Double_t HACDigitizer::ChargeToTconversion(const Double_t& charge, const Int_t& ithr) {
  //Charge(tot) = offset + constant*Exp(slope*tot)
  Double_t tot = fChargeToTConstant[ithr] + fChargeToTSlope[ithr] * TMath::Log(charge - fChargeToTOffset[ithr]);
  return tot;
}
