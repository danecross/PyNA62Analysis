// ********************************************************************
// * License and Disclaimer                                           *
// *                                                                  *
// * The  Geant4 software  is  copyright of the Copyright Holders  of *
// * the Geant4 Collaboration.  It is provided  under  the terms  and *
// * conditions of the Geant4 Software License,  included in the file *
// * LICENSE and available at  http://cern.ch/geant4/license .  These *
// * include a list of copyright holders.                             *
// *                                                                  *
// * Neither the authors of this software system, nor their employing *
// * institutes,nor the agencies providing financial support for this *
// * work  make  any representation or  warranty, express or implied, *
// * regarding  this  software system or assume any liability for its *
// * use.  Please see the license in the file  LICENSE  and URL above *
// * for the full disclaimer and the limitation of liability.         *
// *                                                                  *
// * This  code  implementation is the result of  the  scientific and *
// * technical work of the GEANT4 collaboration.                      *
// * By using,  copying,  modifying or  distributing the software (or *
// * any work based  on the software)  you  agree  to acknowledge its *
// * use  in  resulting  scientific  publications,  and indicate your *
// * acceptance of all terms of the Geant4 Software license.          *
// ********************************************************************
// --------------------------------------------------------------------
// History:
//
// Modified by Alina Kleimenova & Joel Swallow (June 2019)
// - Added G4BeamLine input option 
//   (use G4BeamLine simulation (Marcel R.) output [Target--Cedar] and 
//    inject particles which reach Cedar front plane [z=69.2m] into NA62MC)
//
// Modified by Viacheslav Duk (05.2019)
// - forced triple pion decays from K3pi (via capped lifetime) added 
//
// Modified by Lorenza Iacobuzio (October 2018)
// - Added heavy neutral lepton routine: production from D mesons and decay to two-body leptonic final state
//
// Modified by Viacheslav Duk, 08.2018
// - forced double pion decays from K3pi (via capped lifetime) added
//
// Modified by Nicolas Lurkin & Evgueni Goudzovski (August 2016)
// - Added KL beam (momentum spectrum from KLEVER); cleanup
//
// E Goudzovski, Oct 2015: optimization, axion producton at Be target
//
// Modified by Giuseppe Ruggiero 2014-02
// - Method to force a specific K+ decay changed
//
// Modified by Sergey Podolsky 2013-10-25
//
// Modifed by Giuseppe Ruggiero 2012-01-30
// - New beam generator using turtle added
// - Flyo beam generator removed
// - Pileup beam generation removed
//
// Modified by Spasimir Balev
//
// Modified by Sergey Podolsky 2011-01-21
//
// Modified by Giuseppe Ruggiero
// - Flyo beam generator added
// - Pileup beam generator added
//
// Modified by Cari Cesarotti
// - Old Axion generations removed, new exotic gun to replace
//
// Created by Antonino Sergi (Antonino.Sergi@cern.ch) 2008-03-30
// --------------------------------------------------------------------

/// \class PrimaryGeneratorAction
/// \Brief
/// Generation of the primary "beam" particle
/// \EndBrief
/// \Detailed
/// For each beam type defined by /beam/SetBeam in the macro file, a corresponding primary particle
/// is generated. Beam K+/pi+ are generated by interfacing to Turtle.
/// \EndDetailed

#include "NA62Global.hh"
#include "PrimaryGeneratorAction.hh"
#include "ExoticParticleGun.hh"
#include "G4GeneralParticleSource.hh"
#include "G4ParticleGun.hh"
#include "G4DecayTable.hh"
#include "G4ParticleTable.hh"
#include "G4ParticleDefinition.hh"
#include "G4PhysicalConstants.hh"
#include "beam.hh"
#include "G4CMCDecayer.hh"
#include "DatacardManager.hh"
#include "PrimaryGeneratorMessenger.hh"
#include "G4RunManager.hh"
#include "RootIOManager.hh"
#include "Math/WrappedTF1.h"
#include "Math/WrappedMultiTF1.h"
#include "Math/AdaptiveIntegratorMultiDim.h"
#include "Math/GaussLegendreIntegrator.h"
#include "Math/BrentMinimizer1D.h"
#include "TMinuit.h"
#include "TGenPhaseSpace.h"
#include "PhysicsList.hh"
#include "ExoticParticle.hh"
#include "MUV3GeometryParameters.hh"
#include "NA62ConditionsService.hh"

TF2* func_loc; // pointer for MINUIT minimisation (HNL mode)

PrimaryGeneratorAction::PrimaryGeneratorAction(DetectorConstruction* myDC, EventAction& myEVACT) :
  fMaxKaonMomentum(-1.0),
  fExoticProdMode(0), myDetector(myDC), inputEventFile(NULL),
  fCurrentInputEvent(0), fMaxInputEvent(0), fNKinePartsBr(nullptr),
  fKinePartsBr(nullptr), fKinePartsInput(nullptr) {
  fMyEventAct = &myEVACT;
  fParticleTable = G4ParticleTable::GetParticleTable();
  fMessenger = new PrimaryGeneratorMessenger(this);

  // Default settings for the GPS mode
  fParticleGun = new G4GeneralParticleSource();
  fParticleGun->SetParticleDefinition(fParticleTable->FindParticle("pi+"));
  fParticleGun->SetParticleTime(0.0*ns);
  fParticleGun->SetParticlePosition(G4ThreeVector(0.0*m, 0.0*m, 0.0*m));

  fMGun = new MatrixGun();
  fExoticPartGun = new ExoticParticleGun();
  fAxionGun = new G4ParticleGun(fParticleTable->FindParticle("Exotic0"), 1);
  fExoticDaughterGun1 = new G4ParticleGun(fParticleTable->FindParticle("Exotic0"), 1);
  fExoticDaughterGun2 = new G4ParticleGun(fParticleTable->FindParticle("Exotic0"), 1);
  fExoticCounter = 0;
  fBeamType = 0; // Generation mode defined by /beam/SetBeam: turtle, gps, ...
  fTurtleBeam  = nullptr; // The turtle generator
  fParticleDef = nullptr; // Used to turtle generation
  fReadCharmSpectrum = false;

  // Run-dependent K+ beam fine tuning parameters
  fRunNumber  = 0;
  fAlignmentX = 0.0;
  fAlignmentY = 0.0;
  fMomentumScaleFactor = 1.0;

  // Some quantities for HNL mode

  // Masses
  fMe        = fParticleTable->FindParticle("e-")       ->GetPDGMass();
  fMmu       = fParticleTable->FindParticle("mu-")      ->GetPDGMass();
  fMtau      = fParticleTable->FindParticle("tau-")     ->GetPDGMass();
  fMpi       = fParticleTable->FindParticle("pi+")      ->GetPDGMass();
  fMpi0      = fParticleTable->FindParticle("pi0")      ->GetPDGMass();
  fMrho      = fParticleTable->FindParticle("rho+")     ->GetPDGMass();
  fMrho0     = fParticleTable->FindParticle("rho0")     ->GetPDGMass();
  fMeta      = fParticleTable->FindParticle("eta")      ->GetPDGMass();
  fMetaprime = fParticleTable->FindParticle("eta_prime")->GetPDGMass();
  fMD        = fParticleTable->FindParticle("D+")       ->GetPDGMass();
  fMDS       = fParticleTable->FindParticle("Ds+")      ->GetPDGMass();
  fMD0       = fParticleTable->FindParticle("D0")       ->GetPDGMass();
  fMK        = fParticleTable->FindParticle("kaon+")    ->GetPDGMass();
  fMK0       = fParticleTable->FindParticle("kaon0")    ->GetPDGMass();
  fMp        = fParticleTable->FindParticle("proton")   ->GetPDGMass();
  fMKStar    = 891.76;
  fMK0Star   = 895.55;

  // Lifetimes
  fDlife   = fParticleTable->FindParticle("D+")  ->GetPDGLifeTime();
  fDSlife  = fParticleTable->FindParticle("Ds+") ->GetPDGLifeTime();
  fD0life  = fParticleTable->FindParticle("D0")  ->GetPDGLifeTime();  
  ftaulife = fParticleTable->FindParticle("tau-")->GetPDGLifeTime();

  // Constants
  fhc       = 197.327E-12; // MeV mm
  fGF       = 1.166E-11; // MeV^-2
  fPi       = 130.41;  // MeV
  fRho      = 1.04E5; // MeV^2
  fD        = 222.6;
  fDS       = 280.1;
  fK        = 159.8;
  fEta      = 1.2*fPi;
  fEtaprime = -0.45*fPi;
  fsigmacc  = 2.3*75.; //mubarn at sqrt(s) = 82 GeV (400 GeV proton on Be(9) (mBe = 9*1 GeV), taken from Gaia's note

  // CKM
  fVcs = 0.9734;
  fVcd = 0.2252;
  fVud = 0.9743;
  fVus = 0.2253;

  // Form factors, pseudoscalar and vector mesons
  fDK0   = 0.745; // f+
  fDpi0  = 0.648;
  fD0K   = 0.736;
  fD0pi  = 0.637;
  fgDK0  = -0.495; // f-
  fgDpi0 = -0.435;
  fgD0K  = fgDK0;
  fgD0pi = fgDpi0;

  fA0D  = 0.398;
  fA1D  = 0.47;
  fA2D  = -1.24;
  fVD   = 0.66;
  fA0D0 = 0.4;
  fA1D0 = 0.47;
  fA2D0 = -1.24;
  fVD0  = 0.66;

  // Fragmentation fractions
  ffD  = 0.246;
  ffD0 = 0.565;
  ffDS = 0.08;

  // NA62 parameters
  fpMom         = 400000.; // MeV
  fBeA          = 4;
  fBeDensity    = 1.85; // g/cm3
  fpBeLambda    = 421.; // mm
  ftargetLength = 400.; // mm
  fCuA          = 29;
  fCuDensity    = 8.96; // g/cm3
  fpCuLambda    = 153.; // mm
  fTAXLength    = 1615.; // mm
  fTAXDistance  = 23070.;
  fbeamLength   = 102425.; // mm

  // Other parameters
  fPTotal[0] = 0.13966; //Probabilities for species: DPlus, DSPlus, DMinus, DSMinus, D0, D0Bar from pp (np) interactions in the target
  fPTotal[1] = 0.04231;
  fPTotal[2] = 0.17527;
  fPTotal[3] = 0.05024;
  fPTotal[4] = 0.26369;
  fPTotal[5] = 0.32883;

  fDecay = nullptr;

  // Settings for external particle beam
  fExternalParticlesInitialized = false;
  
  // G4BeamLine output read
  fG4Beam        = nullptr;
  fG4BeamLineOut = nullptr;
  // Settings for K3pi simulation with at least two forced pion decays
  fPionTau = fParticleTable->FindParticle("pi+")->GetPDGLifeTime();
  fZmax    = MUV3GeometryParameters::GetInstance()->GetFeWallZStart();
}

PrimaryGeneratorAction::~PrimaryGeneratorAction() {
  if (fTurtleBeam) delete fTurtleBeam;
  if (fExoticPartGun) delete fExoticPartGun;
  if (fDecay) delete fDecay;
  if (fG4BeamLineOut) fG4BeamLineOut->Close();
}

void PrimaryGeneratorAction::GeneratePrimaries(G4Event* anEvent) {
  fMyEventAct->FillRandomEnginesStates();
  TRandom3* RandomDecay = (RandomGenerator::GetInstance())->GetRandomDecay();

  // Instantiating new event
  MCTruthManager::GetInstance()->NewEvent();

  switch (fBeamType) {

  case 1: // "gps"
    {
      fParticleGun->GeneratePrimaryVertex(anEvent);
      break;
    }
  case 2: // "matrixgun"
    {
      fMGun->GeneratePrimaryVertex(anEvent);
      break;
    }
  case 4: // Exotic gun mode
    {
      KinePart * exotic = MCTruthManager::GetInstance()->AddParticle(); //to add exotic to KineParts
      fExoticPartGun->GeneratePrimaries(anEvent, exotic);
      break;
    }

  case 5: // Replay mode -- not documented (???)
    {
      if (inputEventFile==NULL) {
	G4cout << "[PrimaryGeneratorAction] Error: Input file process is not found" << G4endl;
	exit(kWrongConfiguration);
      }
      if (fCurrentInputEvent==fMaxInputEvent) {
	G4cout << "[PrimaryGeneratorAction] Error: Input file process is finished" << G4endl;
	exit(kWrongConfiguration);
      }
      fKinePartsBr->GetEntry(fCurrentInputEvent);
      G4int Nobj = fKinePartsInput->GetEntries();
      if (!Nobj) {
	G4cout << "[PrimaryGeneratorAction] Error: KinePart bank is empty" << G4endl;
	exit(kWrongConfiguration);
      }

      vector<G4int> tracksID;
      for(G4int iPart=0; iPart<Nobj; iPart++){
	KinePart* Particle = static_cast<KinePart*>(fKinePartsInput->At(iPart));
	G4double startPozZ = Particle->GetProdPos().Z();
	G4double endPozZ = Particle->GetEndPos().Z();
	if (startPozZ < 219546.0 && endPozZ > 219546.0) {
	  if (Particle->GetID() > 1) {
	    vector<G4int>::iterator i = find(tracksID.begin(), tracksID.end(), Particle->GetID());
	    if (!(i != tracksID.end())) {
	      tracksID.push_back(Particle->GetID());
	      G4ThreeVector position = G4ThreeVector(Particle->GetProdPos().X()*mm, Particle->GetProdPos().Y()*mm, startPozZ*mm);
	      G4double time = 0.0;
	      G4PrimaryVertex* vertex = new G4PrimaryVertex(position, time);
	      G4ThreeVector momentum = G4ThreeVector(Particle->GetInitialMomentum().X(), Particle->GetInitialMomentum().Y(), Particle->GetInitialMomentum().Z());
	      G4PrimaryParticle* primaryParticle = new G4PrimaryParticle(fParticleTable->FindParticle(Particle->GetPDGcode()), momentum.x(), momentum.y(), momentum.z());
	      primaryParticle->SetMass(fParticleTable->FindParticle(Particle->GetPDGcode())->GetPDGMass());
	      // G4double part_energy = sqrt(Particle->GetInitialEnergy());
	      primaryParticle->SetCharge(fParticleTable->FindParticle(Particle->GetPDGcode())->GetPDGCharge());
	      vertex->SetPrimary(primaryParticle);
	      anEvent->AddPrimaryVertex(vertex);
	    }
	  }
	}
      }
      fCurrentInputEvent++;
      break;
    }

  case 6: // KL production at the entrance to the decay volume
    {
      fParticleDef = fParticleTable->FindParticle("kaon0L");

      // For forced KL decay, account for the decay probability first
      if (DatacardManager::GetInstance()->GetDecayForce()) {
	G4double Prob_survival;
	do {
	  GenerateKLMomentum();
	  G4double bgct = f4Momentum.beta()*f4Momentum.gamma()*c_light*fParticleDef->GetPDGLifeTime();
	  Prob_survival = exp(-DatacardManager::GetInstance()->GetDecayPath()/bgct);
	  // probability of KL decay before reaching the FV is not taken into account yet...
	} while (RandomDecay->Uniform()<Prob_survival);
      }
      else {
	GenerateKLMomentum();
      }

      G4LorentzVector PosTime = GenerateKLPositionTime();
      G4ThreeVector Pos       = PosTime.vect(); // mm
      G4double Time           = PosTime.t();    // ns
      G4PrimaryParticle *BeamParticle = new
	G4PrimaryParticle(fParticleDef, f4Momentum.px(), f4Momentum.py(), f4Momentum.pz()); // MeV

      // Attach daughters if the forced decay mode is set.
      // The daughters are boosted into the INITIAL kaon rest frame in the decay generators.
      // However Geant4 then makes a correction to boost them into the FINAL kaon rest frame.

      if (DatacardManager::GetInstance()->GetDecayForce()) {

	// Set the pre-assigned decay time to the beam kaon (KL)
	BeamParticle->SetProperTime(ProperTime(fParticleDef->GetPDGLifeTime(), Pos.z()));

	if (!fDecay) fDecay = new G4CMCDecayer();
	G4int Ndaughters = fDecay->Generate
	  (f4Momentum.x(), f4Momentum.y(), f4Momentum.z(), f4Momentum.e());
	for (G4int j=0; j<Ndaughters; j++) {
	  CMCParticle *part = fDecay->GetParticles()->at(j);
	  G4ParticleDefinition* daughter = fParticleTable->FindParticle(part->fPid);
	  G4PrimaryParticle *daughterpart = new
	    G4PrimaryParticle(daughter, part->fPx*GeV, part->fPy*GeV, part->fPz*GeV); // GeV-->MeV conversion
	  daughterpart->SetPolarization(part->fPolX, part->fPolY, part->fPolZ);
	  BeamParticle->SetDaughter(daughterpart);
	}
      }

      // Define the event and attach the beam particle to the event
      G4PrimaryVertex *PrimaryVertex = new G4PrimaryVertex(Pos, Time);
      PrimaryVertex->SetPrimary(BeamParticle);
      anEvent->AddPrimaryVertex(PrimaryVertex);
      break;
    }

  case 50: // HNL production and decay
    {
      if (ExoticParticle::Definition(0)->GetPDGStable() == kTRUE) {
	G4cout << "[PrimaryGeneratorAction] ERROR: stable/invisible decay mode not implemented for heavy neutral leptons. Please set a different exotic decay mode in the macro file." << G4endl;
	exit(kWrongConfiguration);
      }

      if (ExoticParticle::Definition(0)->GetPDGMass() >= fMDS) {
	G4cout << "[PrimaryGeneratorAction] ERROR: heavy neutral lepton mass bigger than D meson masses. Please set a different mass in the macro file." << G4endl;
	exit(kWrongConfiguration);
      }

      G4DecayTable *Table = ExoticParticle::Definition(0)->GetDecayTable();
      G4String Name1 = Table->GetDecayChannel(0)->GetDaughterName(0);
      G4String Name2 = Table->GetDecayChannel(0)->GetDaughterName(1);

      if (Table->GetDecayChannel(0)->GetNumberOfDaughters() != 2 || ((Name1 != "pi+" && Name1 != "pi-" && Name1 != "rho+" && Name1 != "rho-") || (Name2 != "mu+" && Name2 != "mu-" && Name2 != "e+" && Name2 != "e-")))  {
	G4cout << "[PrimaryGeneratorAction] ERROR: mode not implemented for heavy neutral leptons. Please set a different exotic decay mode in the macro file." << G4endl;
	exit(kWrongConfiguration);
      }

      if (ExoticParticle::Definition(0)->GetPDGMass() < (Table->GetDecayChannel(0)->GetDaughter(0)->GetPDGMass() + Table->GetDecayChannel(0)->GetDaughter(1)->GetPDGMass())) {
	G4cout << "[PrimaryGeneratorAction] ERROR: heavy neutral lepton too light to decay into " << Name1 << " " << Name2 << ". Please set a different hnl mass or exotic decay mode in the macro file." << G4endl;
        exit(kWrongConfiguration);
      }

      GenerateHeavyNeutrino(anEvent, RandomDecay);
      break;
    }

  case 51: // external generator
    {
      if (!fExternalParticlesInitialized) InitializeExternalParticlesArray();
      G4int evID = anEvent->GetEventID();
      fParticleDef = fParticleTable->FindParticle(fExternalParticlesArray.pdg_code[evID]);
      G4ThreeVector P = G4ThreeVector
	(fExternalParticlesArray.px[evID],
	 fExternalParticlesArray.py[evID],
	 fExternalParticlesArray.pz[evID]);
      G4double mass = fParticleDef->GetPDGMass();
      f4Momentum = G4LorentzVector(P, sqrt(P.mag2()+mass*mass));
      G4PrimaryParticle *ExternalBeamParticle = new
        G4PrimaryParticle(fParticleDef, f4Momentum.x(), f4Momentum.y(), f4Momentum.z());
      G4ThreeVector Pos
        (fExternalParticlesArray.x[evID],
	 fExternalParticlesArray.y[evID],
	 fExternalParticlesArray.z[evID]);
      G4double Time = fExternalParticlesArray.z[evID]/c_light;  
      G4PrimaryVertex *PrimaryVertex = new G4PrimaryVertex(Pos, Time);
      PrimaryVertex->SetPrimary(ExternalBeamParticle);
      anEvent->AddPrimaryVertex(PrimaryVertex);
      break;
    }

  case 52: // new beam from geant4beamline
  {
    std::vector<Int_t> eventIDtree;
    Bool_t ForcedKaonDecay = false;
    Bool_t ForcedPionDecay = false;
    ForcedKaonDecay = DatacardManager::GetInstance()->GetDecayForce() && (DatacardManager::GetInstance()->GetDecayType() < 200);
    ForcedPionDecay = DatacardManager::GetInstance()->GetDecayForce() && (DatacardManager::GetInstance()->GetDecayType() > 200)  &&
                     (DatacardManager::GetInstance()->GetDecayType() < 300);
    // ! no regeneration in case not in the acceptance...
    if (!fG4Beam){
      fG4Beam = (TTree*)fG4BeamLineOut->Get(Form("/NTuple/%s", fG4BeamStartZPosition.data()));
      if ((!fG4FileName.contains("Kaon") && ForcedKaonDecay) || (!fG4FileName.contains("Pion") && ForcedPionDecay))
        std::cout << "Warning: The input file " << fG4FileName << " may not contain beam particles for the forced decay mode "
                  << DatacardManager::GetInstance()->GetDecayType() << std::endl;
      if (!fG4Beam){
        std::cout << "Error: G4BeamLine tree was not found!" << std::endl;
        exit(kWrongConfiguration);
      }
      // Add beam alignment:
      fAlignmentX = 0*mm; // left 0 for now
      fAlignmentY = 0*mm; // left 0 for now
      fMomentumScaleFactor = 1; // left 1 for now
      G4cout << "[PrimaryGeneratorAction] Beam alignment x,y [mm]: " <<
        Form("%4.2f", fAlignmentX/mm) << " " << Form("%4.2f", fAlignmentY/mm) << G4endl;
      G4cout << "[PrimaryGeneratorAction] Beam momentum scale factor: " <<
        Form("%5.3f", fMomentumScaleFactor) << G4endl;
    }
    // Tree variables:
    auto x(0.), y(0.), z(0.), px(0.), py(0.), pz(0.), initx(0.), inity(0.);
    auto eventid(0.), pdgid(0.);
    fG4Beam->SetBranchAddress( "Px",      &px       );
    fG4Beam->SetBranchAddress( "Py",      &py       );
    fG4Beam->SetBranchAddress( "Pz",      &pz       );
    fG4Beam->SetBranchAddress( "x",       &x        );
    fG4Beam->SetBranchAddress( "y",       &y        );
    fG4Beam->SetBranchAddress( "z",       &z        );
    fG4Beam->SetBranchAddress( "EventID", &eventid  );
    fG4Beam->SetBranchAddress( "PDGid",   &pdgid    );
    fG4Beam->SetBranchAddress( "InitX",   &initx    );
    fG4Beam->SetBranchAddress( "InitY",   &inity    );

    Int_t rand = RandomDecay->Uniform(fG4Beam->GetEntries()); // pick random event
    fG4Beam->GetEvent(rand);
    Int_t randevt = eventid;

    Bool_t ForceDecay(kTRUE); // only one beam particle decay per event
    for (Int_t iEvt(0); iEvt < fG4Beam->GetEntries(); ++iEvt){
      fG4Beam->GetEvent(iEvt);
      if (eventid!=randevt) continue;
      fParticleDef    = fParticleTable->FindParticle(pdgid);
      G4double mass   = fParticleDef->GetPDGMass();
      G4ThreeVector P = fMomentumScaleFactor * G4ThreeVector(px, py, pz);         
      f4Momentum      = G4LorentzVector(P, sqrt(P.mag2() + mass*mass));

      G4PrimaryParticle *G4BeamParticle = new G4PrimaryParticle
	(fParticleDef, f4Momentum.x(), f4Momentum.y(), f4Momentum.z());  
      G4ThreeVector Pos(x + fAlignmentX, y + fAlignmentY, z);

      // Forced decay mode: attach daughters.
      // For beam K+ or pi+ depending on decay type, momentum and initial position
      if (((ForcedKaonDecay && pdgid==321) || (ForcedPionDecay && pdgid==211)) && 
	  ForceDecay && pz>70000 && (sqrt(pow(initx,2)+pow(inity,2))<1.0)) {
        ForcedDecay(G4BeamParticle, Pos);
        ForceDecay=kFALSE;
      } // end of "forced beam particle decay" condition
      G4double Time = z/c_light;
      G4PrimaryVertex *PrimaryVertex = new G4PrimaryVertex(Pos, Time); 
      PrimaryVertex->SetPrimary(G4BeamParticle);
      anEvent->AddPrimaryVertex(PrimaryVertex);
    }
    break;
  }

  default: // TURTLE beam generation
    {
      // Turtle and alignment initialization
      if (!fTurtleBeam) {
	fTurtleBeam = new FastBeam(DatacardManager::GetInstance()->GetTurtleDatacardFileName());
	fParticleDef = fParticleTable->FindParticle(fParticleName);
	if (!fParticleDef) {
	  G4cout << "[PrimaryGeneratorAction] Error: Invalid beam particle specified: " <<
	    fParticleName << G4endl;
	  exit(kWrongConfiguration);
	}
	fAlignmentX = DatacardManager::GetInstance()->GetBeamAlignmentX()*mm;
	fAlignmentY = DatacardManager::GetInstance()->GetBeamAlignmentY()*mm;
	fMomentumScaleFactor = DatacardManager::GetInstance()->GetBeamMomentumScaleFactor();
	G4cout << "[PrimaryGeneratorAction] Beam alignment x,y [mm]: " <<
	  Form("%4.2f", fAlignmentX/mm) << " " << Form("%4.2f", fAlignmentY/mm) << G4endl;
	G4cout << "[PrimaryGeneratorAction] Beam momentum scale factor: " <<
	  Form("%5.3f", fMomentumScaleFactor) << G4endl;
      }

      // Compute the maximum decay probability (at p = 70 GeV/c)
      G4double Prob_decay_max = 1.0;
      if (fParticleName == "kaon+" || fParticleName == "pi+") {
	Prob_decay_max = MaxDecayProb(70000., fParticleDef->GetPDGMass(), fParticleDef->GetPDGLifeTime());
      }

      // Transport the beam particle through the beam line up to the G4 starting point
      G4double Prob_decay = 999.;
      do {
	fTurtleBeam->SetN(0);
	fTurtleBeam->Generate();

	//Note: fTurtleBeam is in GeV/c
	//      G4 needs MeV/c
	//      Fortran decay model needs GeV/c
	//      Convert GeV->MeV <=> *GeV
	//              MeV->GeV <=> /GeV

	// All the quantities in the following 7 lines are in [MeV]
	G4ThreeVector P = fMomentumScaleFactor * GeV *
	  G4ThreeVector(fTurtleBeam->GetPx(0),
			fTurtleBeam->GetPy(0),
			fTurtleBeam->GetPz(0));
	G4double mass = fParticleDef->GetPDGMass();
	G4double E = sqrt(P.mag2() + mass*mass);
	f4Momentum = G4LorentzVector(P, E);

	if ((fParticleName == "kaon+" || fParticleName == "pi+") &&
	    DatacardManager::GetInstance()->GetDecayForce()) {
	  G4double bgct = f4Momentum.beta()*f4Momentum.gamma()*c_light*fParticleDef->GetPDGLifeTime();
	  Prob_decay = 1.0 - exp(-DatacardManager::GetInstance()->GetDecayPath()/bgct);
	}
	else {
	  Prob_decay = 999.; // no rejection if forced decay is not required
	}
      } while (RandomDecay->Uniform() > Prob_decay/Prob_decay_max);

      G4PrimaryParticle *BeamParticle = new
	G4PrimaryParticle(fParticleDef, f4Momentum.x(), f4Momentum.y(), f4Momentum.z()); // MeV
      G4ThreeVector Pos
	(fTurtleBeam->GetX(0)*m + fAlignmentX,
	 fTurtleBeam->GetY(0)*m + fAlignmentY,
	 fTurtleBeam->GetZ(0)*m); // mm
      G4double Time = fTurtleBeam->GetTime(0);

      // Forced decay mode: attach daughters.
      // The daughters are boosted into the INITIAL kaon rest frame in the decay generators.
      // However Geant4 then makes a correction to boost them into the FINAL kaon rest frame.

      if ((fParticleName == "kaon+" || fParticleName == "pi+") &&
	  DatacardManager::GetInstance()->GetDecayForce()) {
        ForcedDecay(BeamParticle, Pos);
      } // end of "forced beam particle decay" condition

      // Define the event and attach the beam particle to the event
      G4PrimaryVertex *PrimaryVertex = new G4PrimaryVertex(Pos, Time);
      PrimaryVertex->SetPrimary(BeamParticle);
      anEvent->AddPrimaryVertex(PrimaryVertex); // can add multiple vertices, in principle
    }
  }
}

//////////////////////
// For the replay mode

void PrimaryGeneratorAction::SetInputFileName(G4String value) {
  ifstream check_file(value);
  if (check_file.good()) {
    check_file.close();
    inputEventFile = new TFile(value);
    fKinePartsInput = new TClonesArray("KinePart", 1000);
    fKinePartsBr = (((TTree*)inputEventFile->Get("mcEvent"))->GetBranch("mcEvent"))->FindBranch("fRegeneratingTracks");
    fKinePartsBr->SetAddress(&fKinePartsInput);
    fMaxInputEvent = fKinePartsBr->GetEntries();
  }
  else {
    inputEventFile = NULL;
    fKinePartsInput = NULL;
    fKinePartsBr = NULL;
    fMaxInputEvent = -1;
  }
}

/////////////////////////////////////////////////////////////////////////////////
// Generate proper time of a "beam" particle, to ensure its decay (approximately)
// between the user-defined limits obtained via DatacardManager.
// Parameters: mean proper lifetime (tau), initial Z position (z0).

G4double PrimaryGeneratorAction::ProperTime(G4double tau, G4double z0) {
  TRandom3* RandomDecay = (RandomGenerator::GetInstance())->GetRandomDecay();
  G4double bgc  = f4Momentum.beta()*f4Momentum.gamma()*c_light;
  G4double bgct = bgc*tau;
  G4double x1   = (DatacardManager::GetInstance()->GetDecayZmin()-z0) / bgct;
  G4double x2   = (DatacardManager::GetInstance()->GetDecayZmax()-z0) / bgct;
  if (x1<0.0) x1 = 0.0; // protection against Zmin below the Geant4 handover point
  G4double DecayLength = -bgct*log(RandomDecay->Uniform(exp(-x2), exp(-x1)));
  return DecayLength/bgc;
}

////////////////////////////////////////
// Initialization for external beam mode

void PrimaryGeneratorAction::InitializeExternalParticlesArray() {
  G4int NumberOfEventsInOneJob = DatacardManager::GetInstance()->GetRunBeamOn();
  unsigned int iSeed = DatacardManager::GetInstance()->GetRandDecaySeed();
  vector<G4int> rand_vec(NumberOfEventsInOneJob);
  TRandom3 randomValue;
  randomValue.SetSeed(iSeed); // different seed for each job
  fExternalParticlesArray.pdg_code.reserve(NumberOfEventsInOneJob);
  fExternalParticlesArray.x.reserve(NumberOfEventsInOneJob);
  fExternalParticlesArray.y.reserve(NumberOfEventsInOneJob);
  fExternalParticlesArray.z.reserve(NumberOfEventsInOneJob);
  fExternalParticlesArray.px.reserve(NumberOfEventsInOneJob);
  fExternalParticlesArray.py.reserve(NumberOfEventsInOneJob);
  fExternalParticlesArray.pz.reserve(NumberOfEventsInOneJob);
  G4int NumberOfLines = 0; // with particle information
  string srt_not_used;

  fExternalParticlesFile.open
    (NA62ConditionsService::GetInstance()->GetFullPath(fExternalParticlesFileName));
  while (getline(fExternalParticlesFile, srt_not_used)) NumberOfLines++;
  if (NumberOfEventsInOneJob > NumberOfLines) {
    G4cout << "[PrimaryGeneratorAction] Error: Input file too small; reduce /run/beamOn" << G4endl;
    exit(kWrongConfiguration);
  }
  fExternalParticlesFile.clear();
  fExternalParticlesFile.seekg(0, ios::beg);
  // Define random line in the input file for each event in the job:
  // the Knuth algorithm
  G4int im=0, in=0;
  for (in=0; in<NumberOfLines && im<NumberOfEventsInOneJob; ++in) {
    unsigned int rn = NumberOfLines - in;
    unsigned int rm = NumberOfEventsInOneJob - im;
    if (randomValue.Integer(NumberOfLines*2) % rn < rm)
      rand_vec[im++] = in; // take it
  }
  G4int pdg_code_temp;
  G4double x_temp, y_temp, z_temp, px_temp, py_temp, pz_temp;
  G4int ParticlesContainerIndex = 0;
  for (G4int i=0; i<NumberOfLines; i++) {
    fExternalParticlesFile >> pdg_code_temp >> x_temp >> y_temp >> z_temp >> px_temp >> py_temp >> pz_temp;
    if (i == rand_vec[ParticlesContainerIndex]) {
      fExternalParticlesArray.pdg_code[ParticlesContainerIndex] = pdg_code_temp;
      fExternalParticlesArray.x[ParticlesContainerIndex] = x_temp;
      fExternalParticlesArray.y[ParticlesContainerIndex] = y_temp;
      fExternalParticlesArray.z[ParticlesContainerIndex] = z_temp;
      fExternalParticlesArray.px[ParticlesContainerIndex] = px_temp;
      fExternalParticlesArray.py[ParticlesContainerIndex] = py_temp;
      fExternalParticlesArray.pz[ParticlesContainerIndex] = pz_temp;
      ParticlesContainerIndex++;
    }
    if (ParticlesContainerIndex == NumberOfEventsInOneJob) break;
  }
  fExternalParticlesFile.close();
  fExternalParticlesInitialized = true;
}

void PrimaryGeneratorAction::SetG4BeamLineInputFileName(G4String value) {
  fG4BeamLineOut = new TFile(NA62ConditionsService::GetInstance()->GetFullPath(value));
  fG4FileName = value;
}

///////////////////////////////////////////////////
// Initialization for HNL daughters generation mode

void PrimaryGeneratorAction::InitializeExoticDaughter(TRandom3* RandomDecay) {
  G4DecayTable *Table = ExoticParticle::Definition(0)->GetDecayTable();
  G4String Name1 = Table->GetDecayChannel(0)->GetDaughterName(0);
  G4String Name2 = Table->GetDecayChannel(0)->GetDaughterName(1);
  Name1 = Name1.strip(1, '+');
  Name1 = Name1.strip(1, '-');
  Name2 = Name2.strip(1, '+');
  Name2 = Name2.strip(1, '-');

  G4double Rand = RandomDecay->Rndm();
  if (Rand<0.5) {
    fExoticDaughterGun1->SetParticleDefinition(fParticleTable->FindParticle(Name1 + "+"));
    fExoticDaughterGun2->SetParticleDefinition(fParticleTable->FindParticle(Name2 + "-"));
  }
  else {
    fExoticDaughterGun1->SetParticleDefinition(fParticleTable->FindParticle(Name1 + "-"));
    fExoticDaughterGun2->SetParticleDefinition(fParticleTable->FindParticle(Name2 + "+"));
  }
}

void PrimaryGeneratorAction::ReadCharmSpectrum() {
  fHDPlusPtPl   = TH2D("DPlusPlPt",   "DPlusPlPt",   50, 0., 250., 10, 0., 5.); // [GeV]
  fHDMinusPtPl  = TH2D("DMinusPlPt",  "DMinusPlPt",  50, 0., 250., 10, 0., 5.); // [GeV]  
  fHDSPlusPtPl  = TH2D("DSPlusPlPt",  "DSPlusPlPt",  50, 0., 250., 10, 0., 5.); // [GeV]
  fHDSMinusPtPl = TH2D("DSMinusPlPt", "DSMinusPlPt", 50, 0., 250., 10, 0., 5.); // [GeV]
  fHD0PtPl      = TH2D("D0PlPt",      "D0PlPt",      50, 0., 250., 10, 0., 5.); // [GeV]
  fHD0BarPtPl   = TH2D("D0BarPlPt",   "D0BarPlPt",   50, 0., 250., 10, 0., 5.); // [GeV]

  ifstream infile(NA62ConditionsService::GetInstance()->GetFullPath("PtVsPlDPlus.dat"));
  G4double Pl, Pt, val;
  while (infile >> Pl >> Pt >> val) { // Pt, Pl are in [GeV], so is the bin assignment
    G4int iPl = (G4int)(Pl / 5.0);
    G4int iPt = (G4int)(Pt / 0.5);
    fHDPlusPtPl.SetBinContent(iPl+1, iPt+1, val);
  }
  infile.close();

  ifstream infile2(NA62ConditionsService::GetInstance()->GetFullPath("PtVsPlDMinus.dat"));
  while (infile2 >> Pl >> Pt >> val) { // Pt, Pl are in [GeV], so is the bin assignment
    G4int iPl = (G4int)(Pl / 5.0);
    G4int iPt = (G4int)(Pt / 0.5);
    fHDMinusPtPl.SetBinContent(iPl+1, iPt+1, val);
  }
  infile2.close();

  ifstream infile3(NA62ConditionsService::GetInstance()->GetFullPath("PtVsPlDSPlus.dat"));
  while (infile3 >> Pl >> Pt >> val) { // Pt, Pl are in [GeV], so is the bin assignment
    G4int iPl = (G4int)(Pl / 5.0);
    G4int iPt = (G4int)(Pt / 0.5);
    fHDSPlusPtPl.SetBinContent(iPl+1, iPt+1, val);
  }
  infile3.close();

  ifstream infile4(NA62ConditionsService::GetInstance()->GetFullPath("PtVsPlDSMinus.dat"));
  while (infile4 >> Pl >> Pt >> val) { // Pt, Pl are in [GeV], so is the bin assignment
    G4int iPl = (G4int)(Pl / 5.0);
    G4int iPt = (G4int)(Pt / 0.5);
    fHDSMinusPtPl.SetBinContent(iPl+1, iPt+1, val);
  }
  infile4.close();

  ifstream infile5(NA62ConditionsService::GetInstance()->GetFullPath("PtVsPlD0.dat"));
  while (infile5 >> Pl >> Pt >> val) { // Pt, Pl are in [GeV], so is the bin assignment
    G4int iPl = (G4int)(Pl / 5.0);
    G4int iPt = (G4int)(Pt / 0.5);
    fHD0PtPl.SetBinContent(iPl+1, iPt+1, val);
  }
  infile5.close();

  ifstream infile6(NA62ConditionsService::GetInstance()->GetFullPath("PtVsPlD0Bar.dat"));
  while (infile6 >> Pl >> Pt >> val) { // Pt, Pl are in [GeV], so is the bin assignment
    G4int iPl = (G4int)(Pl / 5.0);
    G4int iPt = (G4int)(Pt / 0.5);
    fHD0BarPtPl.SetBinContent(iPl+1, iPt+1, val);
  }
  infile6.close();

  fReadCharmSpectrum = true;
}

//////////////////////////////////////////////////////////////////////
// Generate KL momentum according to
// H.W. Atherton et al., Precise measurements of particle production
// by 400 GeV/c protons on beryllium targets, CERN Report 80-07 (1980)
// http://sba.web.cern.ch/sba/Documentations/docs/atherton.pdf

void PrimaryGeneratorAction::GenerateKLMomentum() {
  G4double min_df     = -TMath::Pi();
  G4double max_df     =  TMath::Pi();
  G4double acc_ang    =  0.0003 * radian;
  G4double theta_prod = -0.0024 * radian;

  TRandom3* RandomDecay = (RandomGenerator::GetInstance())->GetRandomDecay();

  // Angles wrt the z axis in the reference systems with an angle theta_prod between theta and theta_r
  G4double theta_r = RandomDecay->Uniform()* 2.0 * acc_ang - acc_ang;
  G4double theta   = fabs(theta_r - theta_prod);

  // Angle in the x-y plane: it is uniform between (-pi,+pi)
  G4double df = RandomDecay->Uniform()*(max_df-min_df) + min_df;
  G4double dz = cos(theta_r);
  G4double dr = sqrt(1.0 - dz*dz);
  G4ThreeVector dir(dr*cos(df), dr*sin(df), dz);

  // d2N/dp*dOmega for KL is a linear combination of those for K+ and K-
  // (the so called Wachsmuth rule): KL = (1/4K+) + (3/4K-)

  // K+ Atherton spectrum parameters
  G4double Ap = 0.16;
  G4double Bp = 8.5;
  G4double Cp = 3.0;

  // K- Atherton spectrum parameters
  G4double Am = 0.1;
  G4double Bm = 13.0;
  G4double Cm = 3.5;

  // Flux distribution from Atherton et al.
  G4double p0  = 400*GeV;
  G4double p0r = 0.001*p0;
  G4double Ath_max = 10.0;
  G4double pA = 0.0;
  G4double fAth = 0.0;
  G4double f = Ath_max;
  while (fAth < f) {
    pA = RandomDecay->Uniform()*p0r;
    f  = RandomDecay->Uniform()*Ath_max;
    fAth =
      1.0*Ap*Bp/p0r*exp(-Bp*pA/p0r)*Cp*pA*pA/M_PI*exp(-Cp*pA*pA*theta*theta) +
      3.0*Am*Bm/p0r*exp(-Bm*pA/p0r)*Cm*pA*pA/M_PI*exp(-Cm*pA*pA*theta*theta);
  }
  pA *= 1000.0;
  f4Momentum.setVectM(dir*pA, fParticleTable->FindParticle("kaon0L")->GetPDGMass());
}

/////////////////////////////////////////
// Generate KL initial position at z=zMin

G4LorentzVector PrimaryGeneratorAction::GenerateKLPositionTime() {
  TRandom3* RandomDecay = (RandomGenerator::GetInstance())->GetRandomDecay();

  // Kaon production position
  G4double sx = 0.2*mm;
  G4double sy = 0.3*mm;
  G4double x0 = RandomDecay->Gaus(0.0, sx);
  G4double y0 = RandomDecay->Gaus(0.0, sy);
  G4double z0 = RandomDecay->Uniform(-200.0*mm, 200.0*mm);

  // Position of kaon handover to Geant4 (bypass Cedar, GTK, CHANTI)
  G4double z  = DatacardManager::GetInstance()->GetDecayZmin();
  G4double x  = x0 + (z-z0) * f4Momentum.px() / f4Momentum.pz();
  G4double y  = y0 + (z-z0) * f4Momentum.py() / f4Momentum.pz();

  // Time of handing KL over to Geant4
  G4double path = sqrt((x-x0)*(x-x0)+(y-y0)*(y-y0)+(z-z0)*(z-z0));
  G4double t    = path/(f4Momentum.beta()*c_light);

  return G4LorentzVector(x, y, z, t);
}

// Phasespace for 2-body HNL production mode

G4double PrimaryGeneratorAction::PhaseSpace(G4double Mass1, G4double Mass2, G4double Mass3) {
  G4double phaseSpace =
    TMath::Power(Mass1*Mass1 - Mass2*Mass2 - Mass3*Mass3, 2) - 4.*Mass2*Mass2*Mass3*Mass3;
  return phaseSpace;
}

// Phasespace factor for 2-body HNL production mode
G4double PrimaryGeneratorAction::PhaseSpaceFactor(G4double Mass1, G4double Mass2, G4double Mass3) {
  G4double factor = 0.;
  G4double phaseSpace = PhaseSpace(Mass1, Mass2, Mass3);
  if (phaseSpace > 0.) {
    factor = (Mass1*Mass1*(Mass2*Mass2 + Mass3*Mass3) - TMath::Power(Mass2*Mass2 - Mass3*Mass3,2))*TMath::Power(phaseSpace, 0.5)/(Mass3*Mass3*TMath::Power(Mass1*Mass1 - Mass3*Mass3, 2));
  }
  return factor;
}

// Total BR for 2-body HNL production mode
G4double PrimaryGeneratorAction::TwoBodyBR(G4double Mass1, G4double Mass2, G4double Mass3, G4int Dorigin) {

  G4double brt = 0.;
  G4double life = 0.;
  G4double V = 0.;
  G4double f = 0.;
  G4double a = 0.;
  G4double b = 0.;
  G4double c = 0.;
  G4double d = 0.;

  if (Mass1 >= (Mass2 + Mass3) && PhaseSpaceFactor(Mass1, Mass2, Mass3) > 0.) {
    if (Mass1 == fMD) {
      life = fDlife;
      V = fVcd;
      f = fD;
    }
    else if (Mass1 == fMDS) {
      life = fDSlife;
      V = fVcs;
      f = fDS;
    }
    else if (Mass1 == fMtau) {
      life = ftaulife;
      V = fVud;
      if (Mass3 == fMpi)
	f = fPi;
      else if (Mass3 == fMK)
	f = fK;
      else if (Mass3 == fMrho)
	f = fRho;
    }
    else {
      G4cout << "[TwoBodyBR] ERROR: Unknown mother hadron" << G4endl;
      exit(kWrongConfiguration);
    }

    if (Mass3 != fMe && Mass3 != fMmu && Mass3 != fMtau && Mass3 != fMpi && Mass3 != fMrho && Mass3 != fMK) {
      G4cout << "[TwoBodyBR] ERROR: Unknown 2-body decay" << G4endl;
      exit(kWrongConfiguration);
    }

    if (Mass1 != fMtau) { // D,DS->Nl
      a = life*fGF*fGF*f*f*V*V*Mass1*Mass2*Mass2/(8.*TMath::Pi());
      b = 1. - Mass2*Mass2/(Mass1*Mass1) + 2.*Mass3*Mass3/(Mass1*Mass1);
      c = (1. - Mass3*Mass3/(Mass1*Mass1))*Mass3*Mass3/(Mass2*Mass2);
      d = TMath::Power(1. + Mass2*Mass2/(Mass1*Mass1) - Mass3*Mass3/(Mass1*Mass1), 2.) - 4.*Mass2*Mass2/(Mass1*Mass1);
      brt = a*(b+c)*TMath::Sqrt(d);
    }
    else { // D,DS->taunu; tau->NH (H = pi, K, rho)
      if ((Dorigin == 0 && PhaseSpaceFactor(fMD, fMtau, 0.) > 0.) || (Dorigin == 1 && PhaseSpaceFactor(fMDS, fMtau, 0.))) {
	if (Mass3 == fMpi || Mass3 == fMK) {
	  a = life*fGF*fGF*V*V*f*f*Mass1*Mass1*Mass1/(16.*TMath::Pi());
	  b = TMath::Power(1. - Mass2*Mass2/(Mass1*Mass1), 2.) - (1. + Mass2*Mass2/(Mass1*Mass1))*Mass3*Mass3/(Mass1*Mass1);
	  c = 1. - ((Mass3 - Mass2)*(Mass3 - Mass2)/(Mass1*Mass1));
	  d = 1. - ((Mass3 + Mass2)*(Mass3 + Mass2)/(Mass1*Mass1));
	  brt = a*b*TMath::Sqrt(c*d);
	}
	else if (Mass3 == fMrho) {
	  a = life*fRho*fRho*fGF*fGF*V*V*Mass1*Mass1*Mass1/(8.*TMath::Pi()*Mass3*Mass3);
	  b = TMath::Power(1. - Mass2*Mass2/(Mass1*Mass1), 2.) + (1. + (Mass2*Mass2 - 2.*Mass3*Mass3)/(Mass1*Mass1))*Mass3*Mass3/(Mass1*Mass1);
	  c = 1. - ((Mass3 - Mass2)*(Mass3 - Mass2)/(Mass1*Mass1));
	  d = 1. - ((Mass3 + Mass2)*(Mass3 + Mass2)/(Mass1*Mass1));
	  brt = a*b*TMath::Sqrt(c*d);
	}
      }
    }
  }
  else {
    brt = 0.;
  }
  return brt;
}

// Total BR for 3-body HNL production mode

G4double PrimaryGeneratorAction::ThreeBodyBR(G4double Mass1, G4double Mass2, G4double Mass3, G4double Mass4, G4bool eval, G4bool max, G4double q2, G4double EN, G4int Dorigin) {
  
  G4double br = 0.;
  
  if (Mass1 >= (Mass2 + Mass3 + Mass4)) {
    if (Mass3 == fMK || Mass3 == fMK0 || Mass3 == fMpi || Mass3 == fMpi0) { // D,D0->NHl (H = pi, pi0, K, K0)
      if (Mass1 == fMD || Mass1 == fMD0) { 
	G4double ENmin = Mass2; // N at rest, K and e back to back                                   
	G4double ENmax = (Mass1*Mass1 + Mass2*Mass2 - TMath::Power(Mass4 + Mass3, 2.))/(2.*Mass1); // N one way,K and e other way, their momenta summed equal to the N one
	G4double q2min = TMath::Power(Mass2 + Mass4, 2.); // sum of masses of lepton pair
	G4double q2max = TMath::Power(Mass1 - Mass3, 2.); // sum of 4momenta of lepton pair, when K at rest and N and e back to back
	G4double tau = 0.;
	G4double V = 0.;
	G4double f = 0.;
	G4double a = 0.;
	G4double b = 0.;
	G4double g = 0.;

	if (Mass1 == fMD) {
	  tau = fDlife;
	  if (Mass3 == fMK0) {
	    V = fVcs;
	    f = fDK0;
	    g = fgDK0;
	  }
	  else if (Mass3 == fMpi0) {
	    V = fVcd;
	    f = fDpi0;
	    g = fgDpi0;
	  }
	  else {
	    G4cout << "[ThreeBodyBR] ERROR: Unknown daughter hadron" << G4endl;
	    exit(kWrongConfiguration);
	  }
	}
	else if (Mass1 == fMD0) {
	  tau = fD0life;
	  if (Mass3 == fMK) {
	    V = fVcs;
	    f = fD0K;
	    g = fgD0K;
	  }
	  else if (Mass3 == fMpi) {
	    V = fVcd;
	    f = fD0pi;
	    g = fgD0pi;
	  }
	  else {
	    G4cout << "[ThreeBodyBR] ERROR: Unknown daughter hadron" << G4endl;
	    exit(kWrongConfiguration);
	  }
	}
	a = tau*V*V*fGF*fGF/(64.*TMath::Power(TMath::Pi(), 3.)*Mass1*Mass1);

	std::string function = ThreeBodyFunction(Mass1, Mass3);
	func_loc = new TF2("func", function.c_str());
	func_loc->SetParameter(0, f);
	func_loc->SetParameter(1, Mass1);
	func_loc->SetParameter(2, Mass2);
	func_loc->SetParameter(3, Mass3);
	func_loc->SetParameter(4, Mass4);
	func_loc->SetParameter(5, g);

	if (eval == kFALSE) { // Integral for total BR
	  ROOT::Math::WrappedMultiTF1 wf1(*func_loc, 2);
	  ROOT::Math::AdaptiveIntegratorMultiDim ig;
	  ig.SetFunction(wf1);
	  ig.SetRelTolerance(0.001);
	  double xmin[] = {q2min, ENmin};
	  double xmax[] = {q2max, ENmax};
	  b = ig.Integral(xmin, xmax);
	  br = a*b;
	}
	else {
	  if (max == kFALSE) { // Evaluation at q2, EN for hit/miss
	    br = func_loc->Eval(q2, EN);
	  }
	  else { // Maximum of function for hit/miss
	    TMinuit min;
	    min.SetPrintLevel(-1);
	    min.SetFCN(PrimaryGeneratorAction::minFunctionStatic);
	    min.DefineParameter(0, "x", (q2min+q2max)/2., 0.01, q2min, q2max);
	    min.DefineParameter(1, "y", (ENmin+ENmax)/2., 0.01, ENmin, ENmax);
	    min.Migrad();
            G4double bestX = 0.;
            G4double bestY = 0.;
	    G4double errX = 0.;
	    G4double errY = 0.;
	    min.GetParameter(0, bestX, errX);
	    min.GetParameter(1, bestY, errY);
	    br = func_loc->Eval(bestX, bestY); 
	  }
	}	  
	delete func_loc;
	func_loc = nullptr;
      }
      else {
	br = 0.;
      }
    }
    else if (Mass3 == fMKStar || Mass3 == fMK0Star) { // D,D0->NVl (V = K*, K0*)
      if (Mass1 == fMD || Mass1 == fMD0) {
	G4double ENmin = Mass2; // N at rest, K and e back to back
	G4double ENmax = (Mass1*Mass1 + Mass2*Mass2 - TMath::Power(Mass4 + Mass3, 2.))/(2.*Mass1); // N one way, K and e other way, their momenta summed equal to the N one
	G4double q2min = TMath::Power(Mass2 + Mass4, 2.); // sum of masses of lepton pair
	G4double q2max = TMath::Power(Mass1 - Mass3, 2.); // sum of 4momenta of lepton pair, when K at rest and N and e back to back

	G4double tau = 0.;
	G4double V = 0.;
	G4double f1 = 0.;
	G4double f2 = 0.;
	G4double f3 = 0.;
	G4double f4 = 0.;
	G4double a = 0.;
	G4double b = 0.;
	G4double omega2 = 0.;
	G4double Omega2 = 0.;

	if (Mass1 == fMD) {
	  tau = fDlife;
	  V = fVcs;
	  f1 = fVD/(Mass1 + Mass3);
	  f2 = (Mass1 + Mass3)*fA1D;
	  f3 = -fA2D/(Mass1 + Mass3);
	  f4 = Mass3*(2.*fA0D - fA1D - fA2D) + Mass1*(fA2D - fA1D); // to be multiplied by 1/x        
	}
	else if (Mass1 == fMD0) {
	  tau = fD0life;
	  V = fVcs;
	  f1 = fVD0/(Mass1 + Mass3);
	  f2 = (Mass1 + Mass3)*fA1D0;
	  f3 = -fA2D0/(Mass1 + Mass3);
	  f4 = Mass3*(2.*fA0D0 - fA1D0 - fA2D0) + Mass1*(fA2D0 - fA1D0); // to be multiplied by 1/x 
	}

	omega2 = Mass1*Mass1 - Mass3*Mass3 + Mass2*Mass2 - Mass4*Mass4; // add - 2.*Mass1*y;  
	Omega2 = Mass1*Mass1 - Mass3*Mass3; // add -x                                            
	a = tau*V*V*fGF*fGF/(32.*TMath::Power(TMath::Pi(), 3.)*Mass1*Mass1);

	std::string function = ThreeBodyFunction(Mass1, Mass3);
	func_loc = new TF2("func", function.c_str());
	func_loc->SetParameter(0, omega2);
	func_loc->SetParameter(1, Omega2);
	func_loc->SetParameter(2, Mass2);
	func_loc->SetParameter(3, Mass3);
	func_loc->SetParameter(4, Mass4);
	func_loc->SetParameter(5, f1);
	func_loc->SetParameter(6, f2);
	func_loc->SetParameter(7, f3);
	func_loc->SetParameter(8, f4);
	func_loc->SetParameter(9, Mass1);

	if (eval == kFALSE) {
	  ROOT::Math::WrappedMultiTF1 wf1(*func_loc, 2);
	  ROOT::Math::AdaptiveIntegratorMultiDim ig;
	  ig.SetFunction(wf1);
	  ig.SetRelTolerance(0.001);
	  double xmin[] = {q2min, ENmin};
	  double xmax[] = {q2max, ENmax};
	  b = ig.Integral(xmin, xmax);
	  br = a*b;
	}
	else {
	  if (max == kFALSE) {
            br = func_loc->Eval(q2, EN);
          }
          else {
	    TMinuit min;
	    min.SetPrintLevel(-1);
	    min.SetFCN(PrimaryGeneratorAction::minFunctionStatic);
	    min.DefineParameter(0, "x", (q2min+q2max)/2., 0.01, q2min, q2max);
	    min.DefineParameter(1, "y", (ENmin+ENmax)/2., 0.01, ENmin, ENmax);
	    min.Migrad();
            G4double bestX = 0.;
            G4double bestY = 0.;
	    G4double errX = 0.;
	    G4double errY = 0.;
	    min.GetParameter(0, bestX, errX);
	    min.GetParameter(1, bestY, errY);
	    br = func_loc->Eval(bestX, bestY); 
          }
        }
	delete func_loc;
	func_loc = nullptr;
      }
      else {
	br = 0.;
      }
    }
    else if (Mass1 == fMtau) {
      if ((Dorigin == 0 && PhaseSpaceFactor(fMD, fMtau, 0.) > 0.) || (Dorigin == 1 && PhaseSpaceFactor(fMDS, fMtau, 0.))) {
	G4double b = 0.;
	G4double ENmin = 0.;
	G4double ENmax = 0.;
	G4double life = ftaulife;

	if (Mass3 == 0.1) { // D,DS->taunu_tau; tau->Nlnu_tau 
	  std::string function = ThreeBodyFunction(Mass1, Mass3);
	  Mass3 = 0.;
	  ENmin = Mass2; // N at rest, l and nu back to back
	  ENmax = (Mass1*Mass1 + Mass2*Mass2 - TMath::Power(Mass4 + Mass3, 2.))/(2.*Mass1); // N one way, l and nu other way, their momenta summed equal to the N one
	  TF1 func("func", function.c_str());
	  func.SetParameter(0, life);
	  func.SetParameter(1, Mass1);
	  func.SetParameter(2, Mass2);
	  func.SetParameter(3, fGF);
	  func.SetParameter(4, Mass4);

	  if (eval == kFALSE) {
	    ROOT::Math::WrappedTF1 wf1(func);
	    ROOT::Math::GaussLegendreIntegrator ig;
	    ig.SetFunction(wf1);
	    b = ig.Integral(ENmin, ENmax);
	    br = b;
	  }
	  else {
	    if (max == kFALSE) {
	      br = func.Eval(EN);
	    }
	    else {
	      TF1 funcMinus("funcMinus","-func");
	      ROOT::Math::BrentMinimizer1D bm;
	      bm.SetNpx(1.E3);
	      ROOT::Math::WrappedTF1 wf(funcMinus);
	      bm.SetFunction(wf, ENmin, ENmax);
	      bm.Minimize(1.E2, 1.E-3, 1.E-3);
	      br = -bm.FValMinimum();
	    }
	  }
	}
	else if (Mass3 == 0.01) { // D,DS->taunu_tau; tau->Nlnu_l
	  std::string function = ThreeBodyFunction(Mass1, Mass3);
	  Mass3 = 0.;
	  ENmin = Mass2; // N at rest, l and nu back to back
	  ENmax = (Mass1*Mass1 + Mass2*Mass2 - TMath::Power(Mass4 + Mass3, 2.))/(2.*Mass1); // N one way, l and	nu other way, their momenta summed equal to the N one
	  TF1 func("func", function.c_str());
	  func.SetParameter(0, life);
	  func.SetParameter(1, Mass1);
	  func.SetParameter(2, Mass2);
	  func.SetParameter(3, fGF);
	  func.SetParameter(4, Mass4);

	  if (eval == kFALSE) {
	    ROOT::Math::WrappedTF1 wf1(func);
	    ROOT::Math::GaussLegendreIntegrator ig;
	    ig.SetFunction(wf1);
	    b = ig.Integral(ENmin, ENmax);
	    br = b;
	  }
	  else {
	    if (max == kFALSE) {
	      br = func.Eval(EN);
	    }
	    else {
	      TF1 funcMinus("funcMinus","-func");
	      ROOT::Math::BrentMinimizer1D bm;
	      bm.SetNpx(1.E3);
	      ROOT::Math::WrappedTF1 wf(funcMinus);
	      bm.SetFunction(wf, ENmin, ENmax);
	      bm.Minimize(1.E2, 1.E-3, 1.E-3);
	      br = -bm.FValMinimum();
	    }
	  }
	}
	else {
	  G4cout << "[ThreeBodyBR] ERROR: Unknown neutrino type in N 3-body production mode" << G4endl;
	  exit(kWrongConfiguration);
	}
      }
      else {
	br = 0.;
      }
    }
    else {
      G4cout << "[ThreeBodyBR] ERROR: Unknown N 3-body production mode" << G4endl;
      exit(kWrongConfiguration);
    }
  }
  else {
    br = 0.;
  }
  return br;
}

// Create string function for 3-body total BR of HNL production mode
std::string PrimaryGeneratorAction::ThreeBodyFunction(G4double Mass1, G4double Mass3) {
  std::string function = "";
  if (Mass1 == fMD || Mass1 == fMD0) {  
    if (Mass3 == fMK || Mass3 == fMK0 || Mass3 == fMpi || Mass3 == fMpi0) { // D,D0->NHl
      function = "([5]*[5]*(x*([2]*[2] + [4]*[4]) - TMath::Power([2]*[2] - [4]*[4], 2.)) + 2.*[5]*[0]*([2]*[2]*(2.*[1]*[1] - 2.*[3]*[3] -4.*y*[1] - [4]*[4] + [2]*[2] + x) + [4]*[4]*(4.*y*[1] + [4]*[4] - [2]*[2] - x)) + [0]*[0]*((4.*y*[1] + [4]*[4] - [2]*[2] - x)*(2.*[1]*[1] - 2.*[3]*[3] - 4.*y*[1] - [4]*[4] + [2]*[2] + x) + (2.*[1]*[1] + 2.*[3]*[3] - x)*(x - [2]*[2] - [4]*[4])))";
    }
    else if (Mass3 == fMKStar || Mass3 == fMK0Star) { // D,D0->NVl
      function = "(([6]*[6]/2.)*(x - [2]*[2] - [4]*[4] + ([0] - 2.*[9]*y)*([1] - x - ([0] - 2.*[9]*y))/([3]*[3])) + (([7]+[8]*1./x)*([7]+[8]*1./x)/2.)*([2]*[2] + [4]*[4])*(x - [2]*[2] + [4]*[4])*(([1] - x)*([1] - x)/(4.*[3]*[3]) - x) + 2.*[7]*[7]*[3]*[3]*(([1] - x)*([1] - x)/(4.*[3]*[3]) - x)*([2]*[2] + [4]*[4] - x + ([0] - 2.*[9]*y)*([1] - x - ([0] - 2.*[9]*y))/([3]*[3])) + 2.*[7]*([7]+[8]*1./x)*([2]*[2]*([0] - 2.*[9]*y) + ([1] - x - ([0] - 2.*[9]*y))*[4]*[4])*(([1] - x)*([1] - x)/(4.*[3]*[3]) - x) + 2.*[5]*[6]*(x*(2.*([0] - 2.*[9]*y) - [1] + x) + ([1] - x)*([2]*[2] - [4]*[4])) + ([6]*([7]+[8]*1./x)/2.)*(([0] - 2.*[9]*y)*([1] - x)/([3]*[3])*([2]*[2] - [4]*[4]) + ([1] - x)*([1] - x)*[4]*[4]/([3]*[3]) + 2.*TMath::Power([2]*[2] - [4]*[4], 2.) - 2.*x*([2]*[2] + [4]*[4])) + [6]*[7]*(([1] - x)*([0] - 2.*[9]*y)*([1] - x - ([0] - 2.*[9]*y))/([3]*[3]) + 2.*([0] - 2.*[9]*y)*([4]*[4] - [2]*[2]) + ([1] - x)*([2]*[2] - [4]*[4] - x)) + [5]*[5]*(([1] - x)*([1] - x)*(x - [2]*[2] + [4]*[4]) - 2.*[3]*[3]*(x*x - TMath::Power([2]*[2] - [4]*[4], 2.)) + 2.*([0] - 2.*[9]*y)*([1] - x)*([2]*[2] - x - [4]*[4]) + 2.*([0] - 2.*[9]*y)*([0] - 2.*[9]*y)*x))";
    }
  }
  else if (Mass1 == fMtau) { // D,DS->taunu_tau; tau->Nlnu
    if (Mass3 == 0.1) { //nu_tau
      function = "([0]*[3]*[3]*[1]*[1]*x/(2.*TMath::Power(TMath::Pi(), 3.)))*(1. + ([2]*[2] - [4]*[4])/([1]*[1]) - 2.*x/[1])*(1. - [4]*[4]/([1]*[1] + [2]*[2] - 2.*x*[1]))*(TMath::Sqrt(x*x - [2]*[2]))";
    }
    else if (Mass3 == 0.01) { //nu_e or nu_mu                                       
      function = "([0]*[3]*[3]*[1]*[1]/(4.*TMath::Power(TMath::Pi(), 3.)))*(TMath::Power((1. - [4]*[4]/([1]*[1] + [2]*[2] - 2.*x*[1])), 2.)*TMath::Sqrt(x*x - [2]*[2]))*(([1] - x)*(1. - ([2]*[2] + [4]*[4])/([1]*[1])) - (1. - [4]*[4]/([1]*[1] + [2]*[2] - 2.*x*[1]))*(([1] - x)*([1] - x)/[1] + (x*x - [2]*[2])/(3.*[1])))";
    }
  }
  return function;
}

// MINUIT function object for maximum of function in 3-body production
void PrimaryGeneratorAction::minFunctionStatic(int&, double*, double& result, double* par, int) {
  result = -func_loc->Eval(par[0], par[1]);
}

// Lambda function
G4double PrimaryGeneratorAction::lambda(G4double a, G4double b, G4double c) {
  return a*a + b*b + c*c - 2.*a*b - 2.*a*c - 2.*b*c;
}

// Generation function
void PrimaryGeneratorAction::GenerateHeavyNeutrino(G4Event* anEvent, TRandom3* RandomDecay) {
  InitializeExoticDaughter(RandomDecay);
  G4double Mass1       = fExoticDaughterGun1->GetParticleDefinition()->GetPDGMass();
  G4double Mass2       = fExoticDaughterGun2->GetParticleDefinition()->GetPDGMass();
  G4double Charge1     = fExoticDaughterGun1->GetParticleDefinition()->GetPDGCharge();
  G4double Charge2     = fExoticDaughterGun2->GetParticleDefinition()->GetPDGCharge();
  G4double InitialMass = fAxionGun->GetParticleDefinition()->GetPDGMass();
  G4double MassStep    = PhysicsList::GetInstance()->GetExoticParticleMassStep();
  G4int NPart          = PhysicsList::GetInstance()->GetExoticParticleNumberOfGeneratedParticles();
  G4double HNLMass     = InitialMass + MassStep*(fExoticCounter%NPart);

  G4double prodTime              = 0.;
  G4double TwoBodyLeptonMass     = 0.; // is lepton for 2-body leptonic production and pseudoscalar meson for 2-body semi-leptonic production
  G4double ThreeBodyLeptonMass   = 0.; // is lepton for 3-body production
  G4double ThreeBodyMesonMass    = 0.; // is meson for 3-body production and neutrino for 3-body leptonic production
  G4double TwoBodyLeptonCharge   = 0.;
  G4double ThreeBodyLeptonCharge = 0.;
  G4double ThreeBodyMesonCharge  = 0.;
  G4double Rand                  = 0.;
  G4double ptotal                = 0.;
  G4double motherTheta           = 0.;
  G4double motherPhi             = 0.;
  G4double motherLambda          = 0.;
  G4double motherMomentum        = 0.;
  G4double motherProd            = 0.;
  G4double motherPath            = 0.;
  G4double motherMass            = 0.;
  G4int BiasFactor               = 0;
  G4int iSpecies                 = 0;
  G4int Dorigin                  = -1;

  G4bool inAcc1                   = false;
  G4bool inAcc2                   = false;
  G4bool ThreeBody                = false;
  std::string TwoBodyLeptonName   = "";
  std::string ThreeBodyLeptonName = "";
  std::string ThreeBodyMesonName  = "";

  TLorentzVector HNLMomentum(0.,0.,0.,0.);
  TLorentzVector HNLProdPos(0.,0.,0.,0.);
  TLorentzVector HNLEndPos(0.,0.,0.,0.);
  TLorentzVector P1(0.,0.,0.,0.);
  TLorentzVector P2(0.,0.,0.,0.);
  TRandom *gausRand = new TRandom();

  // Read Pythia distributions for D mesons
  if (!fReadCharmSpectrum) ReadCharmSpectrum();

  fExoticCounter++;
  iSpecies = -1;

  // Start regeneration process

  do {
    
    // Choose D meson species

    G4double rrr = RandomDecay->Rndm();
    
    for (G4int q = 0; q < fNSpecies; q++) {
      if (rrr < ptotal + fPTotal[q]) {
	iSpecies = q; 
	break;
      }
      ptotal += fPTotal[q];
    }
    
    ptotal = 0.;
    
    G4double w0 = 0.;
    G4double z0 = 0.;
    G4double y0 = 0.;
    G4double x0 = 0.;
    G4double thetax0 = 0.;
    G4double thetay0 = 0.;
    G4double pBG = 0.;
    G4double pG = 0.;
    G4double pB = 0.;
    G4double t0 = 0.;

    G4double mesonMomentum = 0.;
    G4double mesonLambda = 0.;
    G4double mesonW = 0.;
    G4double rProduction = 0.;
    G4double xProduction = 0.;
    G4double yProduction = 0.;
    G4double zProduction = 0.;
    G4double mesonBG = 0.;
    G4double mesonG = 0.;
    G4double mesonB = 0.;
    G4double timeProduction = 0.;

    G4double HNLcTheta = 0.;
    G4double HNLTheta = 0.;
    G4double HNLPhi = 0.;
    G4double HNLpStar = 0.;
    G4double mesonPz = 0.;
    G4double mesonPt = 0.;
    G4double expLength = 0.;
    G4double taucTheta = 0.;
    G4double tauTheta = 0.;
    G4double tauPhi = 0.;
    G4double taupStar = 0.;
    G4double tauMom = 0.;
    G4double tauLambda = 0.;
    G4double tauTravelLength = 0.;
    G4double tauW = 0.;
    G4double tauBG = 0.;
    G4double tauG = 0.;
    G4double tauB = 0.;
    G4double motherB = 0.;
    TVector3 HNLbb(0., 0., 0.);
    TVector3 Taubb(0., 0., 0.);
    TLorentzVector tauMomentum(0., 0., 0., 0.);
    G4ThreeVector tauTAXPlane(0., 0., 0.);

    Rand = RandomDecay->Rndm();
    if (Rand <= 0.6) { // D meson production in the Be target
      expLength = fTAXDistance;
      w0 = (1. - TMath::Exp(-ftargetLength/fpBeLambda));
      z0 = -fpBeLambda*TMath::Log(1. - w0*RandomDecay->Rndm());
      pBG = fpMom/fMp;
      pG = TMath::Power(fMp*fMp + fpMom*fpMom, 0.5)/fMp;
      pB = pBG/pG;
      t0 = fabs(z0)/(pB*c_light);
      z0 = z0 - ftargetLength/2.;
      prodTime = t0;
    }
    else { // D meson production in the Cu TAXs
      expLength = fbeamLength;
      w0 = (1. - TMath::Exp(-fTAXLength/fpCuLambda));      
      z0 = -fpCuLambda*TMath::Log(1. - w0*RandomDecay->Rndm()); 
      pBG = fpMom/fMp;
      pG = TMath::Power(fMp*fMp + fpMom*fpMom, 0.5)/fMp;
      pB = pBG/pG;
      t0 = fabs(z0)/(pB*c_light);
      z0 = z0 + fTAXDistance;
      prodTime = t0 + fTAXDistance/(pB*c_light);
    }

    // Choose D meson momentum
    switch (iSpecies) {	  
    case 0: // "D+"
      {
	fHDPlusPtPl.GetRandom2(mesonPz, mesonPt);
	fmesonMass[iSpecies] = fMD;
	fmesonTau[iSpecies] = fDlife;
	break;
      }
    case 1: // "DS+"
      {
	fHDSPlusPtPl.GetRandom2(mesonPz, mesonPt);
	fmesonMass[iSpecies] = fMDS;
	fmesonTau[iSpecies] = fDSlife;
	break;
      }
    case 2: // "D-"
      {
	fHDMinusPtPl.GetRandom2(mesonPz, mesonPt);
	fmesonMass[iSpecies] = fMD;
	fmesonTau[iSpecies] = fDlife;
	break;
      }
    case 3: // "DS-"
      {
	fHDSMinusPtPl.GetRandom2(mesonPz, mesonPt);
	fmesonMass[iSpecies] = fMDS;
	fmesonTau[iSpecies] = fDSlife;
	break;
      }
    case 4: // "D0"
      {
	fHD0PtPl.GetRandom2(mesonPz, mesonPt);
	fmesonMass[iSpecies] = fMD0;
	fmesonTau[iSpecies] = fD0life;
	break;
      }
    case 5: // "D0Bar"
      {
	fHD0BarPtPl.GetRandom2(mesonPz, mesonPt);
	fmesonMass[iSpecies] = fMD0;
	fmesonTau[iSpecies] = fD0life;
	break;
      }
    }

    mesonPz *= 1000.;
    mesonPt *= 1000.;

    // D meson kinematics at production point
    G4double mesonPhi = RandomDecay->Uniform(0.0, 2.0*TMath::Pi());
    G4double mesonTheta = TMath::ATan2(mesonPt, mesonPz);
    G4double mesonP = TMath::Sqrt(mesonPt*mesonPt + mesonPz*mesonPz);
    G4double mesonPx = mesonP*TMath::Sin(mesonTheta)*TMath::Cos(mesonPhi);
    G4double mesonPy = mesonP*TMath::Sin(mesonTheta)*TMath::Sin(mesonPhi);
    G4double px0 = 0.; // due to non-pencil beam
    G4double py0 = 0.; // due to non-pencil beam
    G4double pz0 = 0.; // due to non-pencil beam
    G4double phi0 = 0.;
    G4double theta0 = 0.;

    if (Rand <= 0.6) {
      x0 = 0.;
      y0 = 0.;
      px0 = mesonPx;
      py0 = mesonPy;
      pz0 = mesonPz;
      phi0 = mesonPhi;
      theta0 = mesonTheta;
      prodTime = t0;
    }
    else {
      x0 = gausRand->Gaus(0., 4.7); // due to non-pencil beam
      y0 = gausRand->Gaus(-22., 3.2); // due to non-pencil beam
      thetax0 = TMath::ATan(0.05*1.E-3*x0); // due to non-pencil beam
      thetay0 = TMath::ATan(0.03*1.E-3*y0 - 0.03*1.E-3); // due to non-pencil beam
      Double_t cx = TMath::Cos(thetax0);
      Double_t cy = TMath::Cos(thetay0);
      Double_t sx = TMath::Sin(thetax0);
      Double_t sy = TMath::Sin(thetay0);
      px0 = cx*mesonPx + sy*sx*mesonPy + sx*cy*mesonPz;
      py0 = cy*mesonPy - sy*mesonPz;
      pz0 = -sx*mesonPx + cx*sy*mesonPy + cx*cy*mesonPz;
      theta0 = TMath::ATan2(TMath::Sqrt(px0*px0 + py0*py0), pz0);
      phi0 = TMath::ATan2(py0, px0);
      prodTime += TMath::Sqrt((z0 - fTAXDistance)*(z0 - fTAXDistance) + x0*x0 + y0*y0)/(pB*c_light);
    }

    // Compute total N production BR
    if (iSpecies == 0 || iSpecies == 2) {
      Dorigin = 0;
    }
    else if (iSpecies == 1 || iSpecies == 3) {
      Dorigin = 1;
    }

    G4double BR2De     = TwoBodyBR(fMD,   HNLMass, fMe,   Dorigin);
    G4double BR2Dmu    = TwoBodyBR(fMD,   HNLMass, fMmu,  Dorigin);
    G4double BR2DSe    = TwoBodyBR(fMDS,  HNLMass, fMe,   Dorigin);
    G4double BR2DSmu   = TwoBodyBR(fMDS,  HNLMass, fMmu,  Dorigin);
    G4double BR2DStau  = TwoBodyBR(fMDS,  HNLMass, fMtau, Dorigin);
    G4double BR2taupi  = TwoBodyBR(fMtau, HNLMass, fMpi,  Dorigin);
    G4double BR2tauK   = TwoBodyBR(fMtau, HNLMass, fMK,   Dorigin);
    G4double BR2taurho = TwoBodyBR(fMtau, HNLMass, fMrho, Dorigin);

    G4double BR3DK0e        = ThreeBodyBR(fMD,   HNLMass, fMK0,     fMe,  kFALSE, kFALSE, 0., 0., Dorigin); 
    G4double BR3Dpi0e       = ThreeBodyBR(fMD,   HNLMass, fMpi0,    fMe,  kFALSE, kFALSE, 0., 0., Dorigin);
    G4double BR3D0Ke        = ThreeBodyBR(fMD0,  HNLMass, fMK,      fMe,  kFALSE, kFALSE, 0., 0., Dorigin);
    G4double BR3D0pie       = ThreeBodyBR(fMD0,  HNLMass, fMpi,     fMe,  kFALSE, kFALSE, 0., 0., Dorigin);
    G4double BR3DK0mu       = ThreeBodyBR(fMD,   HNLMass, fMK0,     fMmu, kFALSE, kFALSE, 0., 0., Dorigin);
    G4double BR3Dpi0mu      = ThreeBodyBR(fMD,   HNLMass, fMpi0,    fMmu, kFALSE, kFALSE, 0., 0., Dorigin);
    G4double BR3D0Kmu       = ThreeBodyBR(fMD0,  HNLMass, fMK,      fMmu, kFALSE, kFALSE, 0., 0., Dorigin);
    G4double BR3D0pimu      = ThreeBodyBR(fMD0,  HNLMass, fMpi,     fMmu, kFALSE, kFALSE, 0., 0., Dorigin);
    G4double BR3DK0Stare    = ThreeBodyBR(fMD,   HNLMass, fMK0Star, fMe,  kFALSE, kFALSE, 0., 0., Dorigin);
    G4double BR3D0KStare    = ThreeBodyBR(fMD0,  HNLMass, fMKStar,  fMe,  kFALSE, kFALSE, 0., 0., Dorigin);
    G4double BR3DK0Starmu   = ThreeBodyBR(fMD,   HNLMass, fMK0Star, fMmu, kFALSE, kFALSE, 0., 0., Dorigin);
    G4double BR3D0KStarmu   = ThreeBodyBR(fMD0,  HNLMass, fMKStar,  fMmu, kFALSE, kFALSE, 0., 0., Dorigin);
    G4double BR3tauenu_tau  = ThreeBodyBR(fMtau, HNLMass, 0.1,      fMe,  kFALSE, kFALSE, 0., 0., Dorigin);
    G4double BR3tauenu_e    = ThreeBodyBR(fMtau, HNLMass, 0.01,     fMe,  kFALSE, kFALSE, 0., 0., Dorigin);
    G4double BR3taumunu_tau = ThreeBodyBR(fMtau, HNLMass, 0.1,      fMmu, kFALSE, kFALSE, 0., 0., Dorigin);
    G4double BR3taumunu_mu  = ThreeBodyBR(fMtau, HNLMass, 0.01,     fMmu, kFALSE, kFALSE, 0., 0., Dorigin);

    G4double BR2DTotal[5]  = {BR2De, BR2Dmu, BR2taupi, BR2tauK, BR2taurho}; // mode 0-4
    G4double BR3DTotal[10] = {BR3DK0e, BR3DK0mu, BR3Dpi0e, BR3Dpi0mu, BR3DK0Stare, BR3DK0Starmu, BR3tauenu_tau, BR3taumunu_tau, BR3tauenu_e, BR3taumunu_mu}; // mode 5-14
    G4double BR2DSTotal[6] = {BR2DSe, BR2DSmu, BR2DStau, BR2taupi, BR2tauK, BR2taurho}; // mode 15-20
    G4double BR3DSTotal[4] = {BR3tauenu_tau, BR3taumunu_tau, BR3tauenu_e, BR3taumunu_mu}; // mode 21-24
    G4double BR3D0Total[6] = {BR3D0Ke, BR3D0Kmu, BR3D0pie, BR3D0pimu, BR3D0KStare, BR3D0KStarmu}; // mode 25-30
    G4double BR2Dtot  = BR2De + BR2Dmu + BR2taupi + BR2tauK + BR2taurho;
    G4double BR2DStot = BR2DSe + BR2DSmu + BR2DStau + BR2taupi + BR2tauK + BR2taurho;
    G4double BR3Dtot  = BR3DK0e + BR3DK0mu + BR3Dpi0e + BR3Dpi0mu + BR3DK0Stare + BR3DK0Starmu + BR3tauenu_tau + BR3taumunu_tau + BR3tauenu_e + BR3taumunu_mu;
    G4double BR3DStot = BR3tauenu_tau + BR3taumunu_tau + BR3tauenu_e + BR3taumunu_mu;
    G4double BR3D0tot = BR3D0Ke + BR3D0Kmu + BR3D0pie + BR3D0pimu + BR3D0KStare + BR3D0KStarmu;
    G4double BRDtot   = BR2Dtot + BR3Dtot;
    G4double BRDStot  = BR2DStot + BR3DStot;
    G4double R        = RandomDecay->Rndm();
    G4double RR       = RandomDecay->Rndm();
    G4double pBRtotal = 0.;
    G4int prodMode    = -1;

    Dorigin = -1;

    // Choose between 2- and 3-body production and then choose specific production mode

    if (iSpecies == 0 || iSpecies == 2) { // D
      if (R < BR2Dtot/BRDtot) { // 2-body
	ThreeBody = kFALSE;
        for (G4int q = 0; q < 5; q++) {
	  if (RR < pBRtotal + BR2DTotal[q]/BR2Dtot) {
	    prodMode = q;
	    break;
	  }
	  pBRtotal += BR2DTotal[q]/BR2Dtot;
	}
	pBRtotal = 0.;
      }
      else { // 3-body
	ThreeBody = kTRUE;
	for (G4int q = 0; q < 10; q++) {
	  if (RR < pBRtotal + BR3DTotal[q]/BR3Dtot) {
	    prodMode = q + 5;      
	    break;
	  }                                                                               
	  pBRtotal += BR3DTotal[q]/BR3Dtot;
	}
	pBRtotal = 0.;
      }
    }
    else if (iSpecies == 1 || iSpecies == 3) { // DS
      if (R < BR2DStot/BRDStot) { // 2-body
	ThreeBody = kFALSE;
	for (G4int q = 0; q < 6; q++) {
	  if (RR < pBRtotal + BR2DSTotal[q]/BR2DStot) {
	    prodMode = q + 15;
	    break;
	  }
	  pBRtotal += BR2DSTotal[q]/BR2DStot;
	}
	pBRtotal = 0.;
      }
      else { // 3-body
	ThreeBody = kTRUE;
	for (G4int q = 0; q < 4; q++) {
	  if (RR < pBRtotal + BR3DSTotal[q]/BR3DStot) {
	    prodMode = q + 21;
	    break;
	  }
	  pBRtotal += BR3DSTotal[q]/BR3DStot;
	}
	pBRtotal = 0.;
      }
    }
    else if (iSpecies == 4 || iSpecies == 5) { // D0, 3-body
      ThreeBody = kTRUE;
      for (G4int q = 0; q < 6; q++) {
	if (RR < pBRtotal + BR3D0Total[q]/BR3D0tot) {
	  prodMode = q + 25;
	  break;
	}
	pBRtotal += BR3D0Total[q]/BR3D0tot;
      }
      pBRtotal = 0.;
    }

    // Set lepton and meson charges
    if ((prodMode >= 0 && prodMode <= 4) || (prodMode >= 15 && prodMode <= 20)) { // D,DS 2-body
      if (iSpecies == 0 || iSpecies == 1) {
	TwoBodyLeptonCharge = 1.;
	ThreeBodyLeptonCharge = 0.;
	ThreeBodyMesonCharge = 0.;
      }
      else if (iSpecies == 2 || iSpecies == 3) {
	TwoBodyLeptonCharge = -1.;
	ThreeBodyLeptonCharge = 0.;
	ThreeBodyMesonCharge = 0.;
      }
    }
    else if ((prodMode >= 5 && prodMode <= 14) || (prodMode >= 21 && prodMode <= 30)) { // D,DS,D0 3-body
      if (iSpecies == 0 || iSpecies == 1) {
	TwoBodyLeptonCharge = 0.;
	ThreeBodyLeptonCharge = 1.;
	ThreeBodyMesonCharge = 0.;
      }
      else if (iSpecies == 2 || iSpecies == 3) {
	TwoBodyLeptonCharge = 0.;
	ThreeBodyLeptonCharge = -1.;
	ThreeBodyMesonCharge = 0.;
      }
      else if (iSpecies == 4 || iSpecies == 5) {
	G4double r = RandomDecay->Rndm();
	while (r == 0.5)
	  r = RandomDecay->Rndm();
	if (r < 0.5) {
	  TwoBodyLeptonCharge = 0.;
	  ThreeBodyLeptonCharge = 1.;
	  ThreeBodyMesonCharge = -1.;
	}
	else {
	  TwoBodyLeptonCharge = 0.;
	  ThreeBodyLeptonCharge = -1.;
	  ThreeBodyMesonCharge = 1.;
	}
      }
    }

    if ((prodMode >= 0 && prodMode<= 1) || (prodMode>= 5 && prodMode<=10) ||
	(prodMode >=15 && prodMode<=17) || (prodMode>=25 && prodMode<=30)) {
      // D,DS,D0 meson decay/HNL production (D,DS for 2- and 3-body production)      
      motherMass = fmesonMass[iSpecies];    
      mesonMomentum = TMath::Sqrt(px0*px0 + py0*py0 + pz0*pz0);
      mesonLambda = mesonMomentum/fmesonMass[iSpecies]*c_light*fmesonTau[iSpecies];
      mesonW = (1. - TMath::Exp(-(expLength - z0)/mesonLambda));
      rProduction = -mesonLambda*TMath::Log(1. - mesonW*RandomDecay->Rndm());
      xProduction = x0 + rProduction*TMath::Sin(theta0)*TMath::Cos(phi0);
      yProduction = y0 + rProduction*TMath::Sin(theta0)*TMath::Sin(phi0);
      zProduction = z0 + rProduction*TMath::Cos(theta0);
      mesonBG = mesonMomentum/fmesonMass[iSpecies];
      mesonG = TMath::Power(fmesonMass[iSpecies]*fmesonMass[iSpecies] + mesonMomentum*mesonMomentum, 0.5)/fmesonMass[iSpecies];
      mesonB = mesonBG/mesonG;
      motherB = mesonB;
      motherTheta = theta0;
      motherPhi = phi0;
      timeProduction = rProduction/(mesonB*c_light);
      prodTime += timeProduction;
      HNLProdPos.SetXYZT(xProduction, yProduction, zProduction, prodTime);

      if (prodMode == 0 || prodMode == 1 ||prodMode == 15 ||prodMode == 16 ||prodMode == 17) { // D,DS->Nl
	if (prodMode == 0 || prodMode == 15) {
	  TwoBodyLeptonMass = fMe;
	  TwoBodyLeptonName = "e";
	  ThreeBodyLeptonMass = 0.;
	  ThreeBodyLeptonName = "";
	  ThreeBodyMesonMass = 0.;
	  ThreeBodyMesonName = "";
	}
	else if (prodMode == 1 || prodMode == 16) {
	  TwoBodyLeptonMass = fMmu;
	  TwoBodyLeptonName = "mu";
	  ThreeBodyLeptonMass = 0.;
	  ThreeBodyLeptonName = "";
	  ThreeBodyMesonMass = 0.;
	  ThreeBodyMesonName = "";
	}
	else if (prodMode == 17) {
	  TwoBodyLeptonMass = fMtau;
	  TwoBodyLeptonName = "tau";
	  ThreeBodyLeptonMass = 0.;
	  ThreeBodyLeptonName = "";
	  ThreeBodyMesonMass = 0.;
	  ThreeBodyMesonName = "";
	}

	// HNL kinematics at production point (D,DS leptonic 2-body production)
	HNLcTheta = -1. + 2.*RandomDecay->Rndm(); // flat distribution on costheta
	HNLTheta = TMath::ACos(HNLcTheta);  // theta value in (0,pi);
	HNLPhi = 2.*TMath::Pi()*RandomDecay->Rndm(); // flat distribution		
	HNLpStar = TMath::Power(lambda(fmesonMass[iSpecies]*fmesonMass[iSpecies], TwoBodyLeptonMass*TwoBodyLeptonMass, HNLMass*HNLMass), 0.5)/(2.*fmesonMass[iSpecies]);   
	HNLMomentum.SetPxPyPzE(HNLpStar*TMath::Sin(HNLTheta)*TMath::Cos(HNLPhi), HNLpStar*TMath::Sin(HNLTheta)*TMath::Sin(HNLPhi), HNLpStar*TMath::Cos(HNLTheta), TMath::Power(HNLpStar*HNLpStar + HNLMass*HNLMass, 0.5));

	// HNL boost in lab frame (D,DS leptonic 2-body production)
	HNLbb.SetXYZ(mesonB*TMath::Sin(theta0)*TMath::Cos(phi0), mesonB*TMath::Sin(theta0)*TMath::Sin(phi0), mesonB*TMath::Cos(theta0));
	HNLMomentum.Boost(HNLbb);
      }
    }
    else if ((prodMode >= 2 && prodMode <= 4) || (prodMode >= 11 && prodMode <= 14) || (prodMode >= 18 && prodMode <= 24)) { // D,DS->taunu for 2- and 3-body production

      if (iSpecies == 0 || iSpecies == 2) {
	Dorigin = 0;
      }
      else if (iSpecies == 1 || iSpecies == 3) {
	Dorigin = 1;
      }

      // D meson decay/tau production (D,DS->taunu for 2- and 3-body production)
      mesonMomentum = TMath::Sqrt(px0*px0 + py0*py0 + pz0*pz0);
      mesonLambda = mesonMomentum/fmesonMass[iSpecies]*c_light*fmesonTau[iSpecies];
      mesonW = (1. - TMath::Exp(-(expLength - z0)/mesonLambda));
      rProduction = -mesonLambda*TMath::Log(1. - mesonW*RandomDecay->Rndm());
      xProduction = x0 + rProduction*TMath::Sin(theta0)*TMath::Cos(phi0);
      yProduction = y0 + rProduction*TMath::Sin(theta0)*TMath::Sin(phi0);
      zProduction = z0 + rProduction*TMath::Cos(theta0);
      mesonBG = mesonMomentum/fmesonMass[iSpecies];
      mesonG = TMath::Power(fmesonMass[iSpecies]*fmesonMass[iSpecies] + mesonMomentum*mesonMomentum, 0.5)/fmesonMass[iSpecies];
      mesonB = mesonBG/mesonG;
      timeProduction = rProduction/(mesonB*c_light);
      prodTime += timeProduction;

      // Tau kinematics at production point and boost in lab frame (D,DS->taunu for 2- and 3-body production)
      taucTheta = -1. + 2.*RandomDecay->Rndm(); // flat distribution on costheta
      tauTheta = TMath::ACos(taucTheta);  // theta value in (0,pi);
      tauPhi = 2.*TMath::Pi()*RandomDecay->Rndm(); // flat distribution		
      taupStar = TMath::Power(lambda(fmesonMass[iSpecies]*fmesonMass[iSpecies], 0., fMtau*fMtau), 0.5)/(2.*fmesonMass[iSpecies]);      
      tauMomentum.SetPxPyPzE(taupStar*TMath::Sin(tauTheta)*TMath::Cos(tauPhi), taupStar*TMath::Sin(tauTheta)*TMath::Sin(tauPhi), taupStar*TMath::Cos(tauTheta), TMath::Power(taupStar*taupStar + fMtau*fMtau, 0.5));
      Taubb.SetXYZ(mesonB*TMath::Sin(theta0)*TMath::Cos(phi0), mesonB*TMath::Sin(theta0)*TMath::Sin(phi0), mesonB*TMath::Cos(theta0));      
      tauMomentum.Boost(Taubb);

      // Tau decay/HNL production (D,DS->taunu for 2- and 3-body production)
      tauTheta = tauMomentum.Theta();
      tauPhi = tauMomentum.Phi();      
      tauMom = TMath::Sqrt(tauMomentum.Px()*tauMomentum.Px() + tauMomentum.Py()*tauMomentum.Py() + tauMomentum.Pz()*tauMomentum.Pz());
      tauLambda = tauMom/fMtau*c_light*ftaulife; 
      tauTravelLength = fbeamLength - zProduction;
      tauW = (1. - TMath::Exp(-(tauTravelLength)/tauLambda));
      rProduction = -tauLambda*TMath::Log(1. - tauW*RandomDecay->Rndm());
      xProduction += rProduction*TMath::Sin(tauTheta)*TMath::Cos(tauPhi);
      yProduction += rProduction*TMath::Sin(tauTheta)*TMath::Sin(tauPhi);
      zProduction += rProduction*TMath::Cos(tauTheta);
      tauBG = tauMom/fMtau;
      tauG = TMath::Power(fMtau*fMtau + tauMom*tauMom, 0.5)/fMtau;
      tauB = tauBG/tauG;
      motherB = tauB;
      motherTheta = tauTheta;
      motherPhi = tauPhi;
      timeProduction = rProduction/(tauB*c_light);
      prodTime += timeProduction;
      HNLProdPos.SetXYZT(xProduction, yProduction, zProduction, prodTime);

      if (prodMode == 2 || prodMode == 3 || prodMode == 4 || prodMode == 18 || prodMode == 19 || prodMode == 20) { // D, DS->taunu for 2-body production

	motherMass = fMtau;
	if (prodMode == 2 || prodMode == 18) {
	  TwoBodyLeptonMass = fMpi;
	  TwoBodyLeptonName = "pi";
	  ThreeBodyLeptonMass = 0.;
	  ThreeBodyLeptonName = "";
	  ThreeBodyMesonMass = 0.;
	  ThreeBodyMesonName = "";
	}
        else if (prodMode == 3 || prodMode == 19) {
          TwoBodyLeptonMass = fMK;
          TwoBodyLeptonName = "K";
          ThreeBodyLeptonMass = 0.;
          ThreeBodyLeptonName = "";
          ThreeBodyMesonMass = 0.;
          ThreeBodyMesonName = "";
        }
	else if (prodMode == 4 || prodMode == 20) {
	  TwoBodyLeptonMass = fMrho;
	  TwoBodyLeptonName = "rho";
	  ThreeBodyLeptonMass = 0.;
	  ThreeBodyLeptonName = "";
	  ThreeBodyMesonMass = 0.;
	  ThreeBodyMesonName = "";
	}

	// HNL kinematics at production point (D, DS->taunu for 2-body production)
	HNLcTheta = -1. + 2.*RandomDecay->Rndm(); // flat distribution on costheta
	HNLTheta = TMath::ACos(HNLcTheta);  // theta value in (0,pi);
	HNLPhi = 2.*TMath::Pi()*RandomDecay->Rndm(); // flat distribution		
	HNLpStar = TMath::Power(lambda(fMtau*fMtau, TwoBodyLeptonMass*TwoBodyLeptonMass, HNLMass*HNLMass), 0.5)/(2.*fMtau);      
	HNLMomentum.SetPxPyPzE(HNLpStar*TMath::Sin(HNLTheta)*TMath::Cos(HNLPhi), HNLpStar*TMath::Sin(HNLTheta)*TMath::Sin(HNLPhi), HNLpStar*TMath::Cos(HNLTheta), TMath::Power(HNLpStar*HNLpStar + HNLMass*HNLMass, 0.5));
      
	// HNL boost in lab frame (D, DS->taunu for 2-body production)
	HNLbb.SetXYZ(tauB*TMath::Sin(tauTheta)*TMath::Cos(tauPhi), tauB*TMath::Sin(tauTheta)*TMath::Sin(tauPhi), tauB*TMath::Cos(tauTheta));      
	HNLMomentum.Boost(HNLbb);
      }
    }

    if ((prodMode >= 5 && prodMode <= 14) || (prodMode >= 21 && prodMode <= 30)) { // D,D0,tau 3-body production
      TwoBodyLeptonMass = 0.;
      TwoBodyLeptonName = "";

      if (prodMode >= 5 && prodMode <= 10) { // Set mother
	motherMass = fMD;
      }
      else if (prodMode >= 25 && prodMode <= 30) {
	motherMass = fMD0;
      }
      else if ((prodMode >= 11 && prodMode <= 14) || (prodMode >= 21 && prodMode <= 24)) {
	motherMass = fMtau;
      }

      if (prodMode == 5 || prodMode == 7 || prodMode == 9 || prodMode == 11 || prodMode == 13 || prodMode == 21 || prodMode == 23 || prodMode == 25 || prodMode == 27 || prodMode == 29) { // Set lepton
	ThreeBodyLeptonMass = fMe;
	ThreeBodyLeptonName = "e";
      }
      else {
	ThreeBodyLeptonMass = fMmu;
	ThreeBodyLeptonName = "mu";
      }
      if (prodMode == 5 || prodMode == 6) { // Set meson
	ThreeBodyMesonMass = fMK0;
	ThreeBodyMesonName = "K0";
      }
      else if (prodMode == 7 || prodMode == 8) {
	ThreeBodyMesonMass = fMpi0;
	ThreeBodyMesonName = "pi0";
      }
      else if (prodMode == 9 || prodMode == 10) {
	ThreeBodyMesonMass = fMK0Star;
	ThreeBodyMesonName = "K0*";
      }
      else if (prodMode == 25 || prodMode == 26) {
	ThreeBodyMesonMass = fMK;
	ThreeBodyMesonName = "K";
      }
      else if (prodMode == 27 || prodMode == 28) {
	ThreeBodyMesonMass = fMpi;
	ThreeBodyMesonName = "pi";
      }
      else if (prodMode == 29 || prodMode == 30) {
	ThreeBodyMesonMass = fMKStar;
	ThreeBodyMesonName = "K*";
      }
      else if (prodMode == 11 || prodMode == 12 || prodMode == 21 || prodMode == 22) {
	ThreeBodyMesonMass = 0.1; // nu_tau
	ThreeBodyMesonName = "nu_tau";
      }
      else if (prodMode == 13 || prodMode == 14 || prodMode == 23 || prodMode == 24) {
	ThreeBodyMesonMass = 0.01; // nu_l
	if (ThreeBodyLeptonName == "e") {
	  ThreeBodyMesonName = "nu_e";
	}
	else if (ThreeBodyLeptonName == "mu") {
	  ThreeBodyMesonName = "nu_mu";
	}
      }

      G4double wMax = 0.5;
      G4double W = 0.;
      G4double randW = 0.;
      G4double evalFunc = 0.;                                                   
      G4double randFunc = 0.;                                                    
      G4double funcMax = 0.;                                                                    
      G4double q2 = 0.;                                                                            
      G4double EN = 0.;      
      TGenPhaseSpace Event;
      TLorentzVector Mother(0., 0., 0., motherMass);
      Double_t Daughters[3] = {HNLMass, ThreeBodyLeptonMass, ThreeBodyMesonMass};
      
      do {
	do {
	  Event.SetDecay(Mother, 3, Daughters);
	  W = Event.Generate();
	  randW = RandomDecay->Rndm(); 
	} while (randW > W/wMax);

	TLorentzVector *p1 = Event.GetDecay(0);
	TLorentzVector *p3 = Event.GetDecay(2);
	TLorentzVector p12 = Mother - *p3;
	q2 = p12.Mag2();
	EN = p1->E();

	// Hit and miss for decay kinematics (D,D0,tau 3-body production)           
	
	evalFunc = ThreeBodyBR(motherMass, HNLMass, ThreeBodyMesonMass, ThreeBodyLeptonMass, kTRUE, kFALSE, q2, EN, Dorigin); // f in (q2,EN)
	funcMax = ThreeBodyBR(motherMass, HNLMass, ThreeBodyMesonMass, ThreeBodyLeptonMass, kTRUE, kTRUE, q2, EN, Dorigin); // f max
	randFunc = RandomDecay->Rndm();
      } while (randFunc > evalFunc/funcMax);

      // HNL kinematics at production point (D,D0,tau 3-body production)
      G4double HNLmom = TMath::Sqrt(EN*EN - HNLMass*HNLMass);
      HNLcTheta = -1. + 2.*RandomDecay->Rndm(); // flat distribution on costheta   
      HNLTheta = TMath::ACos(HNLcTheta);  // theta value in (0,pi);
      HNLPhi = 2.*TMath::Pi()*RandomDecay->Rndm();
      HNLMomentum.SetPxPyPzE(HNLmom*TMath::Sin(HNLTheta)*TMath::Cos(HNLPhi), HNLmom*TMath::Sin(HNLTheta)*TMath::Sin(HNLPhi), HNLmom*TMath::Cos(HNLTheta), EN);

      // HNL boost in lab frame (D,D0,tau 3-body production)
      HNLbb.SetXYZ(motherB*TMath::Sin(motherTheta)*TMath::Cos(motherPhi), motherB*TMath::Sin(motherTheta)*TMath::Sin(motherPhi), motherB*TMath::Cos(motherTheta));
      HNLMomentum.Boost(HNLbb);
    }
    else if (prodMode == -1) {
      G4cout << "[PrimaryGeneratorAction] WARNING: no heavy neutral lepton production mode allowed by kinematics. Mother mass: " << fmesonMass[iSpecies] << ", HNL mass: " << HNLMass << G4endl;
      return;
    }

    // Set variables for KineParts
    if (motherMass == fMD ||motherMass == fMD0 || motherMass == fMDS) {
      motherTheta = theta0;
      motherLambda = mesonLambda;
      motherProd = z0;
      motherPath = zProduction - z0;
      motherMomentum = mesonMomentum;
    }
    else if (motherMass == fMtau) {
      motherTheta = tauTheta;
      motherLambda = tauLambda;
      motherProd = zProduction;
      motherPath = tauTravelLength;
      motherMomentum = tauMom;
    }

    G4double HNLPx = HNLMomentum.Px();
    G4double HNLPy = HNLMomentum.Py();
    G4double HNLPz = HNLMomentum.Pz();
    G4double HNLTh = TMath::ATan2(TMath::Sqrt(HNLPx*HNLPx + HNLPy*HNLPy), HNLPz);

    // HNL propagation up to decay volume
    if (DatacardManager::GetInstance()->GetDecayForce()) {
      G4double zmin = DatacardManager::GetInstance()->GetDecayZmin();
      G4double zmax = DatacardManager::GetInstance()->GetDecayZmax();
      G4ThreeVector rMin(xProduction + HNLPx/HNLPz*(zmin - zProduction), yProduction + HNLPy/HNLPz*(zmin - zProduction), zmin);
      G4ThreeVector rMax(xProduction + HNLPx/HNLPz*(zmax - zProduction), yProduction + HNLPy/HNLPz*(zmax - zProduction), zmax);
      G4ThreeVector rDir = rMax;
      rDir -= rMin;
      G4ThreeVector HNLrDecay = rDir;
      HNLrDecay *= RandomDecay->Rndm();
      HNLrDecay += rMin;

      G4double NTravelLength = TMath::Sqrt((HNLrDecay.x() - xProduction)*(HNLrDecay.x() - xProduction) + (HNLrDecay.y() - yProduction)*(HNLrDecay.y() - yProduction) + (HNLrDecay.z() - zProduction)*(HNLrDecay.z() - zProduction));
      prodTime += NTravelLength/c_light;
      HNLEndPos.SetXYZT(HNLrDecay.x(), HNLrDecay.y(), HNLrDecay.z(), prodTime);

      // Daughters production and kinematics at decay point
      G4double Theta = TMath::ACos(-1. + 2.*RandomDecay->Rndm());
      G4double Phi   = 2.*TMath::Pi()*RandomDecay->Rndm();
      G4double pStar = TMath::Power(lambda(HNLMass*HNLMass, Mass1*Mass1, Mass2*Mass2), 0.5)/(2.*HNLMass);

      P1.SetPxPyPzE(pStar*TMath::Sin(Theta)*TMath::Cos(Phi), pStar*TMath::Sin(Theta)*TMath::Sin(Phi), pStar*TMath::Cos(Theta), TMath::Power(pStar*pStar + Mass1*Mass1, 0.5));
      P2.SetPxPyPzE(-pStar*TMath::Sin(Theta)*TMath::Cos(Phi), -pStar*TMath::Sin(Theta)*TMath::Sin(Phi), -pStar*TMath::Cos(Theta), TMath::Power(pStar*pStar + Mass2*Mass2, 0.5));

      // Daughters boost in lab frame
      G4double bg   = HNLMomentum.P()/HNLMass;
      G4double gam  = TMath::Power(HNLMass*HNLMass + HNLMomentum.P()*HNLMomentum.P(), 0.5)/HNLMass;
      G4double beta = bg/gam;
      TVector3 bb(beta*TMath::Sin(HNLMomentum.Theta())*TMath::Cos(HNLMomentum.Phi()), beta*TMath::Sin(HNLMomentum.Theta())*TMath::Sin(HNLMomentum.Phi()), beta*TMath::Cos(HNLMomentum.Theta()));
      P1.Boost(bb);
      P2.Boost(bb);

      // Extrapolation of daughters at downstream plane (MNP33 kick included)
      G4double zMagnet   = 196345.;
      G4double zPlane    = 239009.;
      G4double rMinPlane = 0.;
      G4double rMaxPlane = 1300.;
      G4double pKick     = 270.;

      G4ThreeVector r1MagnPlane(HNLrDecay.x() + P1.Px()/P1.Pz()*(zMagnet - HNLrDecay.z()), HNLrDecay.y() + P1.Py()/P1.Pz()*(zMagnet - HNLrDecay.z()), zMagnet);
      G4ThreeVector r2MagnPlane(HNLrDecay.x() + P2.Px()/P2.Pz()*(zMagnet - HNLrDecay.z()), HNLrDecay.y() + P2.Py()/P2.Pz()*(zMagnet - HNLrDecay.z()), zMagnet);
      G4ThreeVector r1Plane(r1MagnPlane.x() - Charge1*pKick/P1.P()*(zPlane - r1MagnPlane.z()) + P1.Px()/P1.Pz()*(zPlane - r1MagnPlane.z()), r1MagnPlane.y() + P1.Py()/P1.Pz()*(zPlane - r1MagnPlane.z()), zPlane);
      G4ThreeVector r2Plane(r2MagnPlane.x() - Charge2*pKick/P2.P()*(zPlane - r2MagnPlane.z()) + P2.Px()/P2.Pz()*(zPlane - r2MagnPlane.z()), r2MagnPlane.y() + P2.Py()/P2.Pz()*(zPlane - r2MagnPlane.z()), zPlane);
      G4double Rho1 = TMath::Sqrt(r1Plane.x()*r1Plane.x() + r1Plane.y()*r1Plane.y());
      G4double Rho2 = TMath::Sqrt(r2Plane.x()*r2Plane.x() + r2Plane.y()*r2Plane.y());

      inAcc1 = (Rho1 > rMinPlane && Rho1 < rMaxPlane);
      inAcc2 = (Rho2 > rMinPlane && Rho2 < rMaxPlane);

      // Add HNL to KineParts, despite it being in acceptance or not
      KinePart *HNL = MCTruthManager::GetInstance()->AddParticle();
      TString HNLName             = "";
      TString HNLGood             = "bad";
      TString TwoBodyLeptonSign   = "";
      TString ThreeBodyLeptonSign = "";
      TString MesonSign           = "";

      switch (iSpecies) { // Set D meson name
      case 0 :
	{
	  HNLName += "D+"; 
	  break;
	}
      case 1:
	{
	  HNLName += "DS+";
	  break;
	}
      case 2:
	{
	  HNLName += "D-";
	  break;
	}
      case 3:
	{
	  HNLName += "DS-";
	  break;
	}
      case 4:
	{
	  HNLName += "D0";
	  break;
	}
      case 5:
	{
	  HNLName += "D0Bar";
	  break;
	}
      }
      HNLName += "->";

      if (TwoBodyLeptonCharge == -1.) { // Set charges for lepton
	TwoBodyLeptonSign = "-";
      }
      else if (TwoBodyLeptonCharge == 1.) {
	TwoBodyLeptonSign = "+";
      }
      if (ThreeBodyLeptonCharge == -1.) { // Set charges for lepton
	ThreeBodyLeptonSign = "-";
      }
      else if (ThreeBodyLeptonCharge == 1.) {
	ThreeBodyLeptonSign = "+";
      }
      if (ThreeBodyMesonCharge == -1.) { // Set charges for meson
	MesonSign = "-";
      }
      else if (ThreeBodyMesonCharge == 1.) {
	MesonSign = "+";
      }

      if (ThreeBody == kFALSE) {
	if (Dorigin == 0 || Dorigin == 1) { // Set tau chain for 2-body production
	  HNLName += "taunu; tau->" + TwoBodyLeptonName + TwoBodyLeptonSign + "N";
	}
	else {
	  HNLName += TwoBodyLeptonName + TwoBodyLeptonSign + "N";
	}
      }
      else {
	if (Dorigin == 0 || Dorigin == 1) { // Set tau chain for 3-body production 
	  HNLName += "taunu; tau->" + ThreeBodyLeptonName + ThreeBodyLeptonSign + ThreeBodyMesonName + MesonSign + "N";
	}
	else {
	  HNLName += ThreeBodyLeptonName + ThreeBodyLeptonSign + ThreeBodyMesonName + MesonSign + "N";
	}
      }

      HNL->SetParticleName(HNLName);
      HNL->SetParentID(-1);
      HNL->SetParentIndex(-2);
      HNL->SetInitial4Momentum(HNLMomentum);
      HNL->SetFinal4Momentum(HNLMomentum);
      HNL->SetProdPos(HNLProdPos);
      HNL->SetEndPos(HNLEndPos);
      HNL->SetPDGcode(999);
      HNL->SetEndProcessName(HNLGood);
      HNL->SetPosAtCheckPoint(0, TVector3(motherTheta, motherLambda, motherProd)); // Mother meson: production theta, mean free path, Z production point
      HNL->SetPosAtCheckPoint(1, TVector3(theta0, mesonLambda, z0)); // D meson: production theta, mean free path, Z production point
      HNL->SetPosAtCheckPoint(2, TVector3(tauTheta, tauLambda, zProduction)); // tau: production theta, mean free path, Z production point
      HNL->SetMomAtCheckPoint(0, TLorentzVector(motherPath, motherMomentum, HNLTh, TMath::Sqrt(HNLPx*HNLPx + HNLPy*HNLPy + HNLPz*HNLPz))); // Z mother meson path, |p_mother|, HNL production theta, |p_N|
      HNL->SetMomAtCheckPoint(1, TLorentzVector(zProduction-z0, mesonMomentum, 0., 0.)); // Z D meson path, |p_mother|
      HNL->SetMomAtCheckPoint(2, TLorentzVector(tauTravelLength, tauMom, 0., 0.)); // Z tau path, |p_mother|
      HNL->SetMomAtCheckPoint(8, TLorentzVector(x0, y0, theta0, phi0)); // D meson production point in the TAXes, angles of the D meson after the rotation in the TAX

      if (prodMode == 16) {
	HNL->SetMomAtCheckPoint(3, TLorentzVector(mesonMomentum, TMath::Sqrt(px0*px0 + py0*py0), HNLMomentum.P(), HNLMomentum.Pt()));
	if (Mass1 == fMmu)
	  HNL->SetMomAtCheckPoint(4, TLorentzVector(P1.P(), P1.Pt(), 0., 0.));
	else if (Mass2 == fMmu)
	  HNL->SetMomAtCheckPoint(4, TLorentzVector(P2.P(), P2.Pt(), 0., 0.));
      }
      else if (prodMode == 26) {
	HNL->SetMomAtCheckPoint(5, TLorentzVector(mesonMomentum, TMath::Sqrt(px0*px0 + py0*py0), HNLMomentum.P(), HNLMomentum.Pt()));
	if (Mass1 == fMmu)
          HNL->SetMomAtCheckPoint(6, TLorentzVector(P1.P(), P1.Pt(), 0., 0.));
	else if(Mass2 == fMmu)
          HNL->SetMomAtCheckPoint(6, TLorentzVector(P2.P(), P2.Pt(), 0., 0.));
      }

      BiasFactor++;
      if (inAcc1 && inAcc2) {
	BiasFactor--;
	HNLGood = "good";
	HNL->SetEndProcessName(HNLGood);
      }
    }
  } while (!inAcc1 || !inAcc2);

  Event *Evt = MCTruthManager::GetInstance()->GetEvent();  
  Evt->SetEventWeight(BiasFactor);

  // Passing HNL daughters to G4
  fExoticDaughterGun1->SetParticlePosition(G4ThreeVector(HNLEndPos.X(), HNLEndPos.Y(), HNLEndPos.Z()));
  fExoticDaughterGun1->SetParticleTime(prodTime);
  fExoticDaughterGun1->SetParticleMomentumDirection(G4ThreeVector(P1.Px(), P1.Py(), P1.Pz()));
  fExoticDaughterGun1->SetParticleEnergy(P1.E() - Mass1);      
  fExoticDaughterGun1->SetParticleCharge(Charge1);
  fExoticDaughterGun2->SetParticleTime(prodTime);
  fExoticDaughterGun2->SetParticleMomentumDirection(G4ThreeVector(P2.Px(), P2.Py(), P2.Pz()));
  fExoticDaughterGun2->SetParticleEnergy(P2.E() - Mass2);
  fExoticDaughterGun2->SetParticleCharge(Charge2);
  fExoticDaughterGun2->GeneratePrimaryVertex(anEvent);
}

G4double PrimaryGeneratorAction::MaxDecayProb(double p, G4double m, G4double tau) {
  // p = momentum in [MeV/c], m=PDGMass [MeV], tau = PDGlifetime [ns]
  G4LorentzVector p4Momentum = G4LorentzVector(0.0, 0.0, p, sqrt(p*p+m*m));
  G4double bgct = p4Momentum.beta()*p4Momentum.gamma()*c_light*tau;
  G4double Prob_decay_max = 1.0 - exp(-DatacardManager::GetInstance()->GetDecayPath()/bgct);
  return Prob_decay_max;
}

void PrimaryGeneratorAction::ForcedDecay(G4PrimaryParticle *G4BeamParticle, G4ThreeVector Pos){
// Forced decay mode: attach daughters.
// The daughters are boosted into the INITIAL kaon rest frame in the decay generators.
// However Geant4 then makes a correction to boost them into the FINAL kaon rest frame.
  TRandom3* RandomDecay = (RandomGenerator::GetInstance())->GetRandomDecay();

  // Set the pre-assigned beam kaon or pion decay time
  G4BeamParticle->SetProperTime(ProperTime(fParticleDef->GetPDGLifeTime(), Pos.z()));
  if (!fDecay) fDecay = new G4CMCDecayer();
  G4int Ndaughters = fDecay->Generate(f4Momentum.x()/GeV, f4Momentum.y()/GeV, f4Momentum.z()/GeV, f4Momentum.e()/GeV); // GeV
  if (fDecay->GetNTrials()>0) { // set the event weight for biased MC generation
    MCTruthManager::GetInstance()->GetEvent()->SetEventWeight(1.0/fDecay->GetNTrials());
  }

  // Calculate the Z coordinate of the beam kaon decay vertex
  G4double bgc = f4Momentum.beta()*f4Momentum.gamma()*c_light;
  Double_t BeamDecayVertexZ = Pos.z() + bgc*G4BeamParticle->GetProperTime();

  // generate a set of pion event lifetimes with at least 2 potential decays
  G4bool   LifetimesReady = false;
  G4int    NPotentialDecays = 0;
  G4double P[3]; // probabilities of a potential pion decay
  G4double Times[3]; // pion event lifetimes
  G4double MaxProperTimeInTauUnits[3];
  G4double PionTau = fParticleTable->FindParticle("pi+")->GetPDGLifeTime();
  G4double Zmax = MUV3GeometryParameters::GetInstance()->GetFeWallZStart();
  G4double Zmin = BeamDecayVertexZ;
  G4double Weight = 1.;
  G4int MinNumberOfDecays = 2;
  if (DatacardManager::GetInstance()->GetPionDecayForce()==2) MinNumberOfDecays = 3;

  // K3pi Forcing n>=2 pi decays in flight 
  if (DatacardManager::GetInstance()->GetDecayType()==10 && // K3pi decay
      DatacardManager::GetInstance()->GetDecayRadcor()<2 && // non-radiative
      DatacardManager::GetInstance()->GetPionDecayForce()) { // 1 (at least two pion decays) or 2 (three pion decays)
    while(!LifetimesReady) {
      // generate 3 lifetimes
      for (G4int j=0; j<3; j++) Times[j] = -PionTau*log(RandomDecay->Uniform(0., 1.));
      // compare generated times and pion tmax*1.1 [1.1 is a safety factor]
      NPotentialDecays = 0;
      for (G4int j=0; j<Ndaughters; j++) {
        CMCParticle *part = fDecay->GetParticles()->at(j);
        G4double ThisEnergy = part->fEnergy*GeV;
        G4double ThisMomentum = sqrt(part->fPx*part->fPx + part->fPy*part->fPy + part->fPz*part->fPz)*GeV;
        G4double PionVelocity = ThisMomentum/ThisEnergy*c_light;
        MaxProperTimeInTauUnits[j] = 1.1*(Zmax - Zmin)/PionVelocity*(fMpi/ThisEnergy) / PionTau; // 1.1 is a safety factor
        if (Times[j] < MaxProperTimeInTauUnits[j]*PionTau) NPotentialDecays++;
      }
      if (NPotentialDecays>=MinNumberOfDecays) LifetimesReady = true;
    }

    // decay probability for a single pion
    for (G4int j=0; j<3; j++) {
      P[j] = 1. - exp(-MaxProperTimeInTauUnits[j]);
    }
    
    // calculate the weight (probability to have >=2 pion decays)
    if (DatacardManager::GetInstance()->GetPionDecayForce()==1)
      Weight *= P[0]*P[1]*(1.-P[2]) + P[0]*(1.-P[1])*P[2] + (1.-P[0])*P[1]*P[2] + P[0]*P[1]*P[2];

    // calculate the weight for 3 pion decays
    if (DatacardManager::GetInstance()->GetPionDecayForce()==2) 
      Weight *= P[0]*P[1]*P[2];
  }

  for (G4int j=0; j<Ndaughters; j++) {
    CMCParticle *part = fDecay->GetParticles()->at(j);
    G4ParticleDefinition* daughter = fParticleTable->FindParticle(part->fPid);
    G4PrimaryParticle *daughterpart = new G4PrimaryParticle(daughter, part->fPx*GeV, part->fPy*GeV, part->fPz*GeV); // MeV
    daughterpart->SetPolarization(part->fPolX, part->fPolY, part->fPolZ);

    ////////////////////////////////////////////////////////////////////////
    // FORCED MUON DECAY ("CAPPED MUON LIFETIME") SIMULATION:
    // Force the mu+ to have proper time < tmax,
    // where tmax = 0.73%*t0 (0.89%*t0) for K+ decays
    // in the standard (upstream) decay region,
    // and 0.06%*t0 (0.07%*t0) for pi+ decays; t0 is the mean muon lifetime.
    // In this way, all decays of muons from Kmu2 decays (E>3.3 GeV)
    // and Pimu2 decays (E>42 GeV) up to MUV3 are simulated.
    // This mode can be used to evaluate backgrounds due to
    // pimu2 and Kmu2 decays followed by muon decay in flight.
    // The simulation is sped up by a factor of 1/(1-exp(-0.73%)) = 137.487
    // (1/(1-exp(-0.89%)) = 112.860) for kaon decays,
    // and a factor of 1/(1-exp(-0.06%)) = 1667.167 (1/(1-exp(-0.07%)) = 1429.071)
    // for pion decays.

    if (abs(daughter->GetPDGEncoding())==13 &&
        DatacardManager::GetInstance()->GetMuonDecayForce()) {
      Double_t max = 0.0;
      if (DatacardManager::GetInstance()->GetDecayZmin()>100000)
        max = 0.0073; // K+ --> mu+ nu (gamma), standard decay region
      else
        max = 0.0089; // K+ --> mu+ nu (gamma), upstream decay region
      if (DatacardManager::GetInstance()->GetDecayType()==230 ||
  	DatacardManager::GetInstance()->GetDecayType()==231) { // pi+ --> mu+ nu (gamma)
        if (DatacardManager::GetInstance()->GetDecayZmin()>100000) 
          max = 0.0006; // pi+ --> mu+ nu (gamma), standard decay region
        else
          max = 0.0007; // pi+ --> mu+ nu (gamma), upstream decay region
      }
      daughterpart->SetProperTime
        (-daughter->GetPDGLifeTime()*log(RandomDecay->Uniform(exp(-max), 1.0)));
      MCTruthManager::GetInstance()->GetEvent()->SetEventWeight(1.0-exp(-max));
    }

    /////////////////////////////////////////////////////////////////
    // Forced double pion decay (for K3pi with no radiative photons):
    //
    // Force at least two pions from a K3pi decay with no radiative photons (/decay/radcor<=1)
    // to have proper time (i.e. event lifetime) < tmax,
    // where tmax = 1.1*(Zmax - Zmin)/v * (Mpi/Epi),
    // Zmax = 245900 mm (beginning of the Fe wall),
    // Zmin is the Z-coordinate of the K3pi decay,
    // v is the pion velocity, Epi is the initial pion energy.
    // Pion proper times (t1, t2, t3) are generated until 
    // the condition of at least two potential decays is satisfied: N(t<tmax)>=2 .
    // The event is assigned a weight w = P1*P2*(1-P3) + P1*(1-P2)*P3 + (1-P1)*P2*P3 + P1*P2*P3.
    // Here P1 = 1-exp(-tmax1/tau)], similar for P2 and P3.
    // All K3pi events with at least 2 pion decays up to MUV3 are simulated.
    // The simulation is sped up by a factor of ~50.
    // Additional option (/decay/piforce 2): capped proper time for three pions.
    // In this case, the weight is w = P1*P2*P3.

    if (DatacardManager::GetInstance()->GetDecayType()==10 && // K3pi decay
        DatacardManager::GetInstance()->GetDecayRadcor()<2 && // non-radiative
        DatacardManager::GetInstance()->GetPionDecayForce()) { // 1 (at least two pion decays) or 2 (three pion decays)
        // set the previously generated proper time
        daughterpart->SetProperTime(Times[j]);
    } // end of K3pi with forced kaon decay condition

    G4BeamParticle->SetDaughter(daughterpart);
  } // end of loop over daughters

  if (DatacardManager::GetInstance()->GetDecayType()==10 && // K3pi decay
      DatacardManager::GetInstance()->GetDecayRadcor()<2 && // non-radiative
      DatacardManager::GetInstance()->GetPionDecayForce()){ // 1 (at least two pion decays) or 2 (three pion decays)
    MCTruthManager::GetInstance()->GetEvent()->SetEventWeight(Weight);
  }  
}
